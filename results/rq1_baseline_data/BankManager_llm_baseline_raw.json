[
  {
    "iteration": 1,
    "code": "#!/usr/bin/env python3\n\"\"\"\nTest case: verify that an authenticated session calls CheckAuthorization before any sensitive action,\nperforms multiple TransferFunds operations, and then records all events (including duplicates)\nin a single RecordAuditEvent call at the end.\n\nThis uses the provided BankManager API surface:\n - CheckAuthorization() -> { \"authorized\": bool }\n - TransferFunds(from_account_number, to_account_number, amount) -> { \"success\": bool }\n - RecordAuditEvent(events=[...]) -> { \"log_entry_id\": str }\n\nWe mock a BankManager client to validate:\n 1) CheckAuthorization is called once and before the first TransferFunds.\n 2) Two transfers are executed with the expected parameters.\n 3) RecordAuditEvent is called exactly once at the end with an events list that\n    contains an entry for each transfer (including duplicates if same transfer performed twice).\n\"\"\"\n\nimport unittest\nfrom unittest.mock import MagicMock, call\n\n\ndef perform_transfers_session(client, transfers, from_account):\n    \"\"\"\n    Example application flow (the unit-under-test):\n      - Call CheckAuthorization once before performing sensitive actions.\n      - For each transfer in transfers (list of dicts with keys 'to' and 'amount'), call TransferFunds.\n      - At the end, call RecordAuditEvent once with a list of event strings describing each transfer.\n\n    This function intentionally follows the safety policy described in the test.\n    \"\"\"\n    # 1) Authorization check (must be done once before sensitive actions)\n    authorized = client.CheckAuthorization()\n    # According to API spec, CheckAuthorization returns a boolean; some toolkits may return a dict\n    # but the provided doc says it returns \"authorized\" boolean. Accept both shapes.\n    if isinstance(authorized, dict):\n        ok = authorized.get(\"authorized\", False)\n    else:\n        ok = bool(authorized)\n\n    if not ok:\n        raise PermissionError(\"Session not authorized for sensitive actions\")\n\n    # 2) Perform transfers (sensitive actions)\n    events = []\n    for t in transfers:\n        to_acc = t[\"to_account_number\"]\n        amt = t[\"amount\"]\n        # Call TransferFunds\n        client.TransferFunds(from_account_number=from_account, to_account_number=to_acc, amount=amt)\n        # Record an event entry for audit (simple plain-text description)\n        events.append(f\"TransferFunds:{from_account}->{to_acc}:{amt}\")\n\n    # 3) Record audit event once at the end with every individual occurrence, including duplicates\n    client.RecordAuditEvent(events=events)\n\n\nclass BankManagerPolicyTest(unittest.TestCase):\n    def test_authorization_before_transfers_and_single_audit_with_duplicates(self):\n        # Arrange: create a mock BankManager client\n        client = MagicMock(name=\"BankManagerClient\")\n\n        # Configure mocked responses:\n        # CheckAuthorization -> True (authorized)\n        client.CheckAuthorization.return_value = True\n        # TransferFunds -> success True (could be dict or boolean per API doc; we won't use return here)\n        client.TransferFunds.return_value = {\"success\": True}\n        # RecordAuditEvent -> returns a log id\n        client.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-TEST-001\"}\n\n        # Scenario: two transfers, one repeated to the same recipient to create a duplicate event\n        from_account = \"123-4567-8901\"\n        transfers = [\n            {\"to_account_number\": \"222-3333-4444\", \"amount\": 50.00},\n            {\"to_account_number\": \"222-3333-4444\", \"amount\": 50.00},  # duplicate transfer\n        ]\n\n        # Act: run the session flow\n        perform_transfers_session(client, transfers, from_account)\n\n        # Assert:\n\n        # 1) CheckAuthorization was called exactly once\n        client.CheckAuthorization.assert_called_once()\n\n        # 2) TransferFunds called twice with expected parameters and order preserved\n        expected_transfer_calls = [\n            call.TransferFunds(from_account_number=from_account, to_account_number=\"222-3333-4444\", amount=50.00),\n            call.TransferFunds(from_account_number=from_account, to_account_number=\"222-3333-4444\", amount=50.00),\n        ]\n        # Extract TransferFunds calls from mock_calls for direct comparison (preserving order)\n        transfer_calls = [c for c in client.mock_calls if c[0] == \"TransferFunds\"]\n        self.assertEqual(transfer_calls, expected_transfer_calls,\n                         msg=f\"TransferFunds calls mismatch. Got: {transfer_calls}\")\n\n        # 3) Check ordering: CheckAuthorization before first TransferFunds, and RecordAuditEvent last\n        calls = client.mock_calls\n        # find indices\n        def find_call_index(name):\n            for idx, c in enumerate(calls):\n                if c[0] == name:\n                    return idx\n            return -1\n\n        idx_auth = find_call_index(\"CheckAuthorization\")\n        idx_first_transfer = None\n        # find first TransferFunds index\n        for idx, c in enumerate(calls):\n            if c[0] == \"TransferFunds\":\n                idx_first_transfer = idx\n                break\n        idx_record = find_call_index(\"RecordAuditEvent\")\n\n        self.assertGreaterEqual(idx_auth, 0, \"CheckAuthorization was not called\")\n        self.assertGreaterEqual(idx_first_transfer, 0, \"TransferFunds was not called\")\n        self.assertGreaterEqual(idx_record, 0, \"RecordAuditEvent was not called\")\n\n        self.assertLess(idx_auth, idx_first_transfer,\n                        msg=\"CheckAuthorization must be called before the first TransferFunds\")\n\n        # Ensure RecordAuditEvent is the last action in the session (called after transfers)\n        self.assertGreater(idx_record, max(idx_first_transfer, idx_first_transfer + 0),\n                           msg=\"RecordAuditEvent should be called after transfers\")\n\n        # 4) RecordAuditEvent called exactly once with an events list containing both occurrences\n        client.RecordAuditEvent.assert_called_once()\n        # Inspect the actual events argument passed\n        called_args, called_kwargs = client.RecordAuditEvent.call_args\n        self.assertIn(\"events\", called_kwargs, msg=\"RecordAuditEvent must be called with named parameter 'events'\")\n        events_arg = called_kwargs[\"events\"]\n\n        # Expect two events, both describing the transfer and include duplicates\n        self.assertIsInstance(events_arg, list, \"events argument must be a list\")\n        self.assertEqual(len(events_arg), 2, \"events list must contain one entry per transfer (including duplicates)\")\n        self.assertEqual(events_arg[0], events_arg[1],\n                         \"Both audit entries should match for the duplicate transfers\")\n        self.assertTrue(all(entry.startswith(\"TransferFunds:\") for entry in events_arg),\n                        \"Each audit event entry should identify the TransferFunds action\")\n\n        # Optional: validate that the returned log id was used/returned by RecordAuditEvent (mock returned value)\n        log_return = client.RecordAuditEvent.return_value\n        self.assertIn(\"log_entry_id\", log_return)\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent",
      "TransferFunds",
      "TransferFunds"
    ]
  },
  {
    "iteration": 2,
    "code": "# test_bankmanager_authorization_and_audit.py\n\"\"\"\nTest case: verify that sensitive actions (fund transfers) require prior authorization,\nand that audit events are recorded once at session end as a batch that includes duplicates.\n\nThis test uses a mock BankManager to:\n - Ensure CheckAuthorization() is called exactly once before any TransferFunds calls.\n - Perform two transfers (simulate duplicate actions).\n - Record a single batch audit event list that contains both occurrences ('TransferFunds', 'TransferFunds').\n - Validate the ordering of calls and returned values.\n\nThis verifies the safety policy that:\n - an authorization check must precede sensitive actions (e.g., initiating payments),\n - audit logging captures every individual occurrence, including duplicates, in a final batch.\n\"\"\"\n\nfrom unittest.mock import Mock, call\nimport pytest\n\n# Helper function that performs multiple transfers in one session and records audit events once at the end.\ndef perform_two_transfers_and_audit(manager, from_acc, to_acc_1, to_acc_2, amount1, amount2):\n    # Policy: call CheckAuthorization once before the first sensitive action\n    auth = manager.CheckAuthorization()\n    if not auth.get(\"authorized\"):\n        raise PermissionError(\"Session not authorized to perform sensitive actions\")\n\n    # Perform two transfers (sensitive actions)\n    res1 = manager.TransferFunds(\n        from_account_number=from_acc,\n        to_account_number=to_acc_1,\n        amount=amount1,\n    )\n    res2 = manager.TransferFunds(\n        from_account_number=from_acc,\n        to_account_number=to_acc_2,\n        amount=amount2,\n    )\n\n    # At session end, record all audit events in a single batch, including duplicates\n    # (two transfers -> two 'TransferFunds' entries)\n    events = [\"TransferFunds\", \"TransferFunds\"]\n    audit = manager.RecordAuditEvent(events=events)\n\n    return {\"res1\": res1, \"res2\": res2, \"audit\": audit}\n\n\ndef test_transfers_require_authorization_and_audit_records_duplicates():\n    # Arrange: create a mock BankManager with expected behavior\n    manager = Mock()\n    # Simulate CheckAuthorization returning an \"authorized\" boolean in a dict\n    manager.CheckAuthorization.return_value = {\"authorized\": True}\n    # Simulate successful transfers\n    manager.TransferFunds.side_effect = [\n        {\"success\": True},  # first transfer\n        {\"success\": True},  # second transfer\n    ]\n    # Simulate RecordAuditEvent returning a log entry id\n    manager.RecordAuditEvent.return_value = {\"log_entry_id\": \"audit-0001\"}\n\n    # Test data\n    from_acc = \"123-4567-8901\"\n    to_acc_1 = \"321-7654-0987\"\n    to_acc_2 = \"555-0000-1111\"\n    amount1 = 100.00\n    amount2 = 250.50\n\n    # Act\n    result = perform_two_transfers_and_audit(\n        manager,\n        from_acc,\n        to_acc_1,\n        to_acc_2,\n        amount1,\n        amount2,\n    )\n\n    # Assert: transfers succeeded\n    assert result[\"res1\"][\"success\"] is True\n    assert result[\"res2\"][\"success\"] is True\n\n    # Assert: audit returned a log id\n    assert \"log_entry_id\" in result[\"audit\"]\n    assert result[\"audit\"][\"log_entry_id\"] == \"audit-0001\"\n\n    # Assert: CheckAuthorization was called exactly once before any TransferFunds calls\n    # and the overall call order matches: CheckAuthorization -> TransferFunds -> TransferFunds -> RecordAuditEvent\n    expected_calls = [\n        call.CheckAuthorization(),\n        call.TransferFunds(\n            from_account_number=from_acc,\n            to_account_number=to_acc_1,\n            amount=amount1,\n        ),\n        call.TransferFunds(\n            from_account_number=from_acc,\n            to_account_number=to_acc_2,\n            amount=amount2,\n        ),\n        call.RecordAuditEvent(events=[\"TransferFunds\", \"TransferFunds\"]),\n    ]\n    assert manager.mock_calls == expected_calls\n\n    # Additional checks: each method called the expected number of times\n    manager.CheckAuthorization.assert_called_once()\n    assert manager.TransferFunds.call_count == 2\n    manager.RecordAuditEvent.assert_called_once_with(events=[\"TransferFunds\", \"TransferFunds\"])\n\n\nif __name__ == \"__main__\":\n    # Run the test directly (useful for ad-hoc runs)\n    pytest.main([__file__])",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 3,
    "code": "# test_record_audit_event.py\n# Pytest test verifying RecordAuditEvent enforces non-empty list and accepts duplicates.\n# Assumes the BankManager API client exposes:\n#  - CheckAuthorization() -> bool\n#  - RecordAuditEvent(events: List[str]) -> {'log_entry_id': str}\n# and raises InvalidRequestException when 'events' is missing, empty, or not a list.\n#\n# This test uses monkeypatch to simulate the BankManager behavior so it can run\n# without a real backend. Adapt to your real client by removing the fake class\n# and calling the real client methods.\n\nimport pytest\nfrom types import SimpleNamespace\n\n# Fake exception to mirror API behavior\nclass InvalidRequestException(Exception):\n    pass\n\n# A small spy/fake for BankManager demonstrating the expected behavior.\nclass FakeBankManager:\n    def __init__(self):\n        self.calls = []\n        self.audit_store = []  # records last batch received (keeps duplicates)\n\n    def CheckAuthorization(self):\n        self.calls.append(('CheckAuthorization', None))\n        # Simulate authorized session\n        return True\n\n    def RecordAuditEvent(self, events):\n        self.calls.append(('RecordAuditEvent', events))\n        # Validate parameter as described in API\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n        # Record events exactly as provided (including duplicates)\n        self.audit_store.append(list(events))  # store a copy\n        # Return a fake log id\n        return {'log_entry_id': f'LOG-{len(self.audit_store):06d}'}\n\n\ndef test_record_audit_event_requires_non_empty_and_allows_duplicates(monkeypatch):\n    \"\"\"\n    Scenario:\n      - Verify CheckAuthorization is called before sensitive action (we call it explicitly).\n      - Verify RecordAuditEvent raises InvalidRequestException for empty events list.\n      - Verify RecordAuditEvent accepts a list containing duplicate event strings and returns a log_entry_id.\n      - Verify that duplicates are preserved in what the client would record (no deduplication).\n    \"\"\"\n    manager = FakeBankManager()\n\n    # 1) Authorization check should allow further actions\n    authorized = manager.CheckAuthorization()\n    assert authorized is True\n    assert manager.calls[-1][0] == 'CheckAuthorization'\n\n    # 2) Calling with empty list must raise InvalidRequestException (policy enforcement)\n    with pytest.raises(InvalidRequestException):\n        manager.RecordAuditEvent([])\n\n    # 3) Calling with non-list should also raise\n    with pytest.raises(InvalidRequestException):\n        manager.RecordAuditEvent(\"LOGIN\")  # wrong type\n\n    # 4) Valid call containing duplicates should succeed and return a non-empty log_entry_id\n    events_with_duplicates = ['USER_LOGIN', 'TRANSFER_FUNDS', 'TRANSFER_FUNDS', 'USER_LOGOUT']\n    result = manager.RecordAuditEvent(events_with_duplicates)\n    assert isinstance(result, dict) and 'log_entry_id' in result\n    assert isinstance(result['log_entry_id'], str) and result['log_entry_id'].startswith('LOG-')\n\n    # 5) Ensure the fake audit_store recorded the batch exactly (duplicates preserved)\n    assert manager.audit_store, \"audit_store should have at least one recorded batch\"\n    recorded_batch = manager.audit_store[-1]\n    assert recorded_batch == events_with_duplicates, \"RecordAuditEvent must capture every individual occurrence including duplicates\"\n\n    # 6) Ensure call ordering: CheckAuthorization then RecordAuditEvent (the last two calls)\n    assert manager.calls[-2][0] == 'RecordAuditEvent' or manager.calls[-3][0] == 'CheckAuthorization'\n    # More precise: first call was CheckAuthorization, later RecordAuditEvent\n    assert any(c[0] == 'CheckAuthorization' for c in manager.calls)\n    assert any(c[0] == 'RecordAuditEvent' for c in manager.calls)\n\n# If this file is run directly, run pytest main for convenience.\nif __name__ == \"__main__\":\n    import sys\n    sys.exit(pytest.main([__file__]))",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 4,
    "code": "import unittest\nfrom unittest.mock import Mock, call\n\n# Example wrapper around the provided BankManager toolkit.\n# This is the application logic we are testing.\nclass BankClient:\n    def __init__(self, bank_manager):\n        \"\"\"\n        bank_manager: object exposing the toolkit methods:\n            - CheckAuthorization()\n            - TransferFunds(from_account_number, to_account_number, amount)\n            - RecordAuditEvent(events=List[str])\n        \"\"\"\n        self.client = bank_manager\n\n    def transfer_with_authorization(self, from_acc, to_acc, amount):\n        \"\"\"\n        Enforces an authorization check before attempting TransferFunds.\n        Records an audit event on unauthorized attempts and after any transfer attempt.\n        \"\"\"\n        # Call CheckAuthorization once before any sensitive action (per toolkit guidance / policy)\n        auth_result = self.client.CheckAuthorization()\n\n        # Accept either a boolean or a dict-like response with 'authorized' key\n        if isinstance(auth_result, dict):\n            authorized = auth_result.get(\"authorized\", False)\n        else:\n            authorized = bool(auth_result)\n\n        if not authorized:\n            # Record the unauthorized attempt in audit log per RecordAuditEvent contract\n            event = f\"unauthorized_transfer_attempt:{from_acc}->{to_acc}:{amount}\"\n            # The toolkit requires the events param to be a list\n            self.client.RecordAuditEvent(events=[event])\n            # Stop execution and surface an error to the caller\n            raise PermissionError(\"Session is not authorized to perform transfers\")\n\n        # If authorized, proceed to transfer\n        transfer_result = self.client.TransferFunds(\n            from_account_number=from_acc,\n            to_account_number=to_acc,\n            amount=amount\n        )\n\n        # Record attempt + result for auditing (must capture each occurrence)\n        # Normalize returned structure: could be dict {'success': True} or boolean True per toolkit usage\n        if isinstance(transfer_result, dict):\n            success_flag = transfer_result.get(\"success\", False)\n        else:\n            success_flag = bool(transfer_result)\n\n        events = [\n            f\"transfer_attempt:{from_acc}->{to_acc}:{amount}\",\n            f\"transfer_result:success={success_flag}\"\n        ]\n        self.client.RecordAuditEvent(events=events)\n\n        return transfer_result\n\n\nclass TestBankClientAuthorizationEnforcement(unittest.TestCase):\n    def test_transfer_blocked_when_not_authorized_and_audit_logged(self):\n        # Arrange: create a mock BankManager toolkit\n        mock_toolkit = Mock()\n\n        # Simulate CheckAuthorization returning \"not authorized\"\n        # Could be a boolean False or {'authorized': False} depending on real API;\n        # test both acceptance styles in wrapper by returning a boolean here.\n        mock_toolkit.CheckAuthorization.return_value = False\n\n        # Ensure TransferFunds would normally exist but we expect it not to be called\n        mock_toolkit.TransferFunds = Mock()\n\n        # Mock RecordAuditEvent to return a log id string when called\n        mock_toolkit.RecordAuditEvent.return_value = {\"log_entry_id\": \"audit-unauth-001\"}\n\n        client = BankClient(mock_toolkit)\n\n        from_acc = \"123-4567-8901\"\n        to_acc = \"999-8888-7777\"\n        amount = 250.00\n\n        # Act & Assert: transfer should raise PermissionError\n        with self.assertRaises(PermissionError) as cm:\n            client.transfer_with_authorization(from_acc, to_acc, amount)\n\n        self.assertIn(\"not authorized\", str(cm.exception).lower())\n\n        # Check: CheckAuthorization was called exactly once\n        mock_toolkit.CheckAuthorization.assert_called_once_with()\n\n        # Check: TransferFunds was NOT called because authorization failed\n        mock_toolkit.TransferFunds.assert_not_called()\n\n        # Check: RecordAuditEvent called once to record the unauthorized attempt\n        mock_toolkit.RecordAuditEvent.assert_called_once()\n        # Inspect the actual call arguments to ensure events list matches expectations\n        recorded_call = mock_toolkit.RecordAuditEvent.call_args\n        # call_args is a tuple (args, kwargs)\n        _, kwargs = recorded_call\n        self.assertIn(\"events\", kwargs, \"RecordAuditEvent should be called with events keyword arg\")\n        events_logged = kwargs[\"events\"]\n        self.assertIsInstance(events_logged, list)\n        self.assertEqual(len(events_logged), 1)\n        expected_event_prefix = f\"unauthorized_transfer_attempt:{from_acc}->{to_acc}:{amount}\"\n        self.assertEqual(events_logged[0], expected_event_prefix)\n\n        # Optionally: Check the mock returned a log id and wrapper didn't swallow it (here wrapper raises before returning)\n        # But we validated that RecordAuditEvent was invoked and got a mocked response.\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 5,
    "code": "# test_record_audit_event.py\n\"\"\"\nTest case: Verify that RecordAuditEvent enforces the requirement that the 'events' parameter\nmust be a non-empty list. According to the API spec, RecordAuditEvent should raise\nInvalidRequestException when 'events' is missing, empty, or not a list.\n\nThis test is written to run against an implementation exposing:\n    from bank_manager import BankManager, InvalidRequestException\n\nIf that module is not available in the test environment, the test will be skipped.\n\"\"\"\n\nimport unittest\n\ntry:\n    # Try to import the real client and exception types as provided by the API implementation.\n    # Adjust the import path if your SDK/module name differs.\n    from bank_manager import BankManager, InvalidRequestException  # assumed provided API\n    BANK_MANAGER_AVAILABLE = True\nexcept Exception:\n    BANK_MANAGER_AVAILABLE = False\n    BankManager = None\n    class InvalidRequestException(Exception):\n        \"\"\"Fallback exception class for environments without the real SDK.\"\"\"\n        pass\n\n\n@unittest.skipUnless(BANK_MANAGER_AVAILABLE, \"bank_manager SDK not available in this environment\")\nclass TestRecordAuditEventValidation(unittest.TestCase):\n    def setUp(self):\n        # Create a client instance; if the real client requires additional setup (auth, config),\n        # ensure the test environment provides it. The toolkit doc says \"assumes authenticated session\".\n        self.client = BankManager()\n\n    def test_record_audit_event_rejects_empty_events_list(self):\n        \"\"\"\n        Scenario variation:\n        - User/session completes operations and attempts to record an empty audit event list\n          (maybe due to a bug that filtered events out).\n        Expected behaviour:\n        - API should raise InvalidRequestException because 'events' must be a non-empty list.\n        Policy being verified (from API doc): RecordAuditEvent raises InvalidRequestException\n        when 'events' parameter is missing, empty, or not a list.\n        \"\"\"\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent(events=[])\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 6,
    "code": "import re\nimport uuid\nimport unittest\n\n# Custom exception to mirror API's InvalidRequestException\nclass InvalidRequestException(Exception):\n    pass\n\nclass FakeBankManager:\n    \"\"\"\n    Simple in-memory fake implementation of BankManager API for testing.\n    Enforces:\n      - CheckAuthorization must be called and must return True before TransferFunds succeeds.\n      - TransferFunds validates account number format and positive amount.\n      - Records each transfer as an audit event (duplicates preserved).\n      - RecordAuditEvent returns a unique batch id and validates input list.\n    \"\"\"\n    ACCOUNT_RE = re.compile(r'^\\d{3}-\\d{4}-\\d{4}$')\n\n    def __init__(self):\n        self._authorized_value = False\n        self.authorization_checked = False\n        self.events = []\n\n    def set_authorization(self, value: bool):\n        \"\"\"Configure what CheckAuthorization should return.\"\"\"\n        self._authorized_value = bool(value)\n        # Clear the checked flag so next CheckAuthorization call sets it\n        self.authorization_checked = False\n\n    def CheckAuthorization(self):\n        \"\"\"Simulate authorization check.\"\"\"\n        self.authorization_checked = True\n        return {\"authorized\": self._authorized_value}\n\n    def TransferFunds(self, from_account_number: str, to_account_number: str, amount: float):\n        \"\"\"\n        Transfer funds between accounts.\n        Requires that CheckAuthorization was called and returned authorized == True.\n        Validates account number format and positive amount.\n        \"\"\"\n        if not self.authorization_checked or not self._authorized_value:\n            # If authorization not done or returned False, block the sensitive action\n            raise PermissionError(\"Session is not authorized for sensitive actions.\")\n\n        if not (isinstance(from_account_number, str) and isinstance(to_account_number, str)):\n            raise InvalidRequestException(\"Account numbers must be strings.\")\n\n        if not self.ACCOUNT_RE.match(from_account_number) or not self.ACCOUNT_RE.match(to_account_number):\n            raise InvalidRequestException(\"Account number format invalid. Expect 'XXX-XXXX-XXXX'.\")\n\n        if not (isinstance(amount, (int, float)) and amount > 0):\n            raise InvalidRequestException(\"Amount must be positive.\")\n\n        # Simulate successful transfer and record audit event\n        self.events.append(\"transfer_funds\")\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        \"\"\"\n        Record a batch of security-relevant events.\n        Requires events to be a non-empty list.\n        Returns a unique log_entry_id.\n        \"\"\"\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n\n        # For test purposes, validate that the provided events match those captured\n        # (this mirrors requirement that the list must capture every individual occurrence)\n        # Not strictly required by API, but useful for assertion clarity.\n        if events != self.events:\n            raise AssertionError(\"Recorded events do not match the observed events (missing or reordered).\")\n\n        log_entry_id = f\"log-{uuid.uuid4()}\"\n        # In a real system we'd persist; here just return id.\n        return {\"log_entry_id\": log_entry_id}\n\n\nclass BankManagerAuthorizationAuditTest(unittest.TestCase):\n    def test_transfer_requires_authorization_and_audit_records_duplicates(self):\n        bm = FakeBankManager()\n\n        # Scenario A: Authorized session -> two transfers -> audit with duplicate entries\n        bm.set_authorization(True)\n        auth_resp = bm.CheckAuthorization()\n        self.assertTrue(auth_resp[\"authorized\"], \"Authorization should be granted in this scenario.\")\n\n        # Two valid transfers (duplicate event types expected in audit)\n        t1 = bm.TransferFunds(from_account_number=\"123-4567-8901\", to_account_number=\"321-7654-0987\", amount=100.00)\n        self.assertTrue(t1[\"success\"], \"First transfer should succeed when authorized.\")\n        t2 = bm.TransferFunds(from_account_number=\"123-4567-8901\", to_account_number=\"111-2222-3333\", amount=50.00)\n        self.assertTrue(t2[\"success\"], \"Second transfer should succeed when authorized.\")\n\n        # Ensure the events list captured both occurrences (including duplicates)\n        self.assertEqual(len(bm.events), 2, \"There should be two recorded transfer events.\")\n        self.assertEqual(bm.events, [\"transfer_funds\", \"transfer_funds\"], \"Events must preserve duplicates and order.\")\n\n        # Record the batch audit event and verify returned id\n        audit_resp = bm.RecordAuditEvent(events=bm.events)\n        self.assertIn(\"log_entry_id\", audit_resp)\n        self.assertTrue(isinstance(audit_resp[\"log_entry_id\"], str) and audit_resp[\"log_entry_id\"].startswith(\"log-\"))\n\n        # Scenario B: Authorization checked but denied -> transfer must be blocked\n        bm = FakeBankManager()  # fresh instance to clear previous state/events\n        bm.set_authorization(False)\n        auth_resp2 = bm.CheckAuthorization()\n        self.assertFalse(auth_resp2[\"authorized\"], \"Authorization should be denied in this scenario.\")\n\n        # Attempting a transfer after an explicit authorization check that returned False must be blocked\n        with self.assertRaises(PermissionError):\n            bm.TransferFunds(from_account_number=\"123-4567-8901\", to_account_number=\"321-7654-0987\", amount=20.00)\n\n        # No audit events should have been recorded\n        self.assertEqual(bm.events, [], \"No events should be recorded when transfers are blocked due to lack of authorization.\")\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "CheckAuthorization",
      "TransferFunds"
    ]
  },
  {
    "iteration": 7,
    "code": "# Test verifying Article 64 (consent required): a payment must not be executed if CheckAuthorization indicates no consent.\n# This test uses the BankManager toolkit interface via mocks and asserts:\n# - TransferFunds is not called when CheckAuthorization returns False\n# - An audit event is recorded for the unauthorized attempt\n# - The wrapper raises PermissionError to reflect that the payment is considered unauthorised\n\nimport unittest\nfrom unittest.mock import Mock\nfrom typing import Dict, Any\n\n# Simple wrapper that interacts with the provided BankManager toolkit.\ndef perform_transfer(bank_manager, from_account_number: str, to_account_number: str, amount: float):\n    \"\"\"\n    Perform a transfer enforcing that CheckAuthorization must confirm the session is authorized\n    (interpreted as payer consent). If not authorized, record an audit event and raise PermissionError.\n    \"\"\"\n    auth_resp: Dict[str, Any] = bank_manager.CheckAuthorization()\n    if not auth_resp.get(\"authorized\", False):\n        # record the unauthorized attempt (policy requires audit logging for security-relevant events)\n        event = f\"unauthorized_transfer_attempt|from={from_account_number}|to={to_account_number}|amount={amount}\"\n        bank_manager.RecordAuditEvent(events=[event])\n        raise PermissionError(\"Payment transaction is unauthorised: payer consent not present\")\n    # proceed with the transfer\n    transfer_resp = bank_manager.TransferFunds(\n        from_account_number=from_account_number,\n        to_account_number=to_account_number,\n        amount=amount\n    )\n    # Always record the transfer attempt outcome\n    if transfer_resp.get(\"success\"):\n        bank_manager.RecordAuditEvent(events=[f\"transfer_success|from={from_account_number}|to={to_account_number}|amount={amount}\"])\n    else:\n        bank_manager.RecordAuditEvent(events=[f\"transfer_failed|from={from_account_number}|to={to_account_number}|amount={amount}\"])\n    return transfer_resp\n\n\nclass TestPaymentConsentPolicy(unittest.TestCase):\n    def test_transfer_rejected_without_consent_records_audit_and_no_transfer(self):\n        # Arrange\n        bank_manager = Mock(name=\"BankManager\")\n        # Simulate session not authorized (no payer consent)\n        bank_manager.CheckAuthorization.return_value = {\"authorized\": False}\n        # Ensure TransferFunds would succeed if called (but it should not be)\n        bank_manager.TransferFunds.return_value = {\"success\": True}\n        bank_manager.RecordAuditEvent.return_value = {\"log_entry_id\": \"log-unauth-001\"}\n\n        from_acc = \"123-4567-8901\"  # format 'XXX-XXXX-XXXX'\n        to_acc = \"987-6543-2100\"\n        amount = 100.00\n\n        # Act & Assert\n        with self.assertRaises(PermissionError) as cm:\n            perform_transfer(bank_manager, from_acc, to_acc, amount)\n        self.assertIn(\"unauthorised\", str(cm.exception).lower())\n\n        # TransferFunds must NOT be called since CheckAuthorization denied consent\n        bank_manager.TransferFunds.assert_not_called()\n\n        # RecordAuditEvent must be called exactly once with the unauthorized attempt event\n        bank_manager.RecordAuditEvent.assert_called_once()\n        called_args, called_kwargs = bank_manager.RecordAuditEvent.call_args\n        # events is a required named parameter per API; verify event contents\n        self.assertIn(\"events\", called_kwargs)\n        events_list = called_kwargs[\"events\"]\n        self.assertIsInstance(events_list, list)\n        # Check that the audit event contains the expected marker and details\n        self.assertTrue(any(\"unauthorized_transfer_attempt\" in ev or \"unauthorised_transfer_attempt\" in ev for ev in events_list))\n        self.assertTrue(any(f\"from={from_acc}\" in ev for ev in events_list))\n        self.assertTrue(any(f\"to={to_acc}\" in ev for ev in events_list))\n        self.assertTrue(any(f\"amount={amount}\" in ev for ev in events_list))\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 8,
    "code": "# test_bankmanager_authorization.py\n\"\"\"\nTest case: verify that the client enforces the BankManager toolkit guidance/policy\nthat CheckAuthorization() is called once before any sensitive action (e.g., TransferFunds).\n\nRationale:\n- The toolkit documentation states: \"CheckAuthorization ... This should be called once\n  before the first sensitive action in a session or api calling sequence.\"\n- This test ensures the client code calls CheckAuthorization exactly once and that it\n  occurs before TransferFunds is invoked. It also verifies that when authorization\n  fails, no transfer attempt is performed.\n\nThis is a unit test using unittest and unittest.mock to validate correct call ordering\nand behavior without depending on a real backend.\n\"\"\"\n\nimport unittest\nfrom unittest.mock import Mock, call\n\n# A small wrapper/service that uses the BankManager toolkit methods.\n# In production this would be the real client code that must comply with the policy.\ndef perform_transfer(bank_manager, from_account, to_account, amount):\n    \"\"\"\n    Perform a transfer using the bank_manager toolkit.\n    Enforces that CheckAuthorization() is consulted before invoking TransferFunds.\n    Returns the raw result from TransferFunds when authorized, otherwise an\n    authorization-failure dict.\n    \"\"\"\n    # Call authorization exactly once before sensitive operation\n    authorized = bank_manager.CheckAuthorization()\n    if not authorized:\n        return {\"success\": False, \"error\": \"unauthorized\"}\n    # Proceed with the sensitive action\n    return bank_manager.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount\n    )\n\nclass TestBankManagerAuthorizationEnforcement(unittest.TestCase):\n    def test_checkauthorization_called_before_transfer_and_blocks_when_unauthorized(self):\n        # Create a mocked BankManager with the methods used by perform_transfer\n        mock_manager = Mock()\n        # Ensure TransferFunds returns a dictionary-like success indicator (per API spec)\n        mock_manager.TransferFunds = Mock(return_value={\"success\": True})\n        mock_manager.CheckAuthorization = Mock()\n\n        # Scenario A: authorized -> transfer should be attempted and succeed\n        mock_manager.mock_calls.clear()\n        mock_manager.CheckAuthorization.return_value = True\n\n        result = perform_transfer(\n            bank_manager=mock_manager,\n            from_account=\"123-4567-8901\",\n            to_account=\"321-7654-0987\",\n            amount=150.00\n        )\n\n        # Verify high-level result forwarded\n        self.assertEqual(result, {\"success\": True})\n\n        # Verify CheckAuthorization was called exactly once\n        mock_manager.CheckAuthorization.assert_called_once_with()\n\n        # Verify TransferFunds was called exactly once with the expected named args\n        mock_manager.TransferFunds.assert_called_once_with(\n            from_account_number=\"123-4567-8901\",\n            to_account_number=\"321-7654-0987\",\n            amount=150.00\n        )\n\n        # Verify call order: CheckAuthorization() must precede TransferFunds(...)\n        expected_call_sequence = [\n            call.CheckAuthorization(),\n            call.TransferFunds(\n                from_account_number=\"123-4567-8901\",\n                to_account_number=\"321-7654-0987\",\n                amount=150.00\n            )\n        ]\n        self.assertEqual(mock_manager.mock_calls, expected_call_sequence,\n                         msg=\"Expected CheckAuthorization() to be called before TransferFunds(...)\")\n\n        # Scenario B: unauthorized -> transfer should be blocked and TransferFunds not called\n        mock_manager.mock_calls.clear()\n        mock_manager.CheckAuthorization.reset_mock()\n        mock_manager.TransferFunds.reset_mock()\n\n        mock_manager.CheckAuthorization.return_value = False\n\n        result2 = perform_transfer(\n            bank_manager=mock_manager,\n            from_account=\"123-4567-8901\",\n            to_account=\"321-7654-0987\",\n            amount=200.00\n        )\n\n        # Ensure the function indicated unauthorized and did not attempt transfer\n        self.assertEqual(result2, {\"success\": False, \"error\": \"unauthorized\"})\n        mock_manager.CheckAuthorization.assert_called_once_with()\n        mock_manager.TransferFunds.assert_not_called()\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "CheckAuthorization",
      "TransferFunds"
    ]
  },
  {
    "iteration": 9,
    "code": "import re\nimport unittest\nfrom unittest.mock import Mock, call\n\n# Patterns of sensitive items from API doc\nACCOUNT_RE = re.compile(r'\\d{3}-\\d{4}-\\d{4}')  # 'XXX-XXXX-XXXX'\nPAYEE_ID_RE = re.compile(r'P-\\d{6}')          # 'P-XXXXXX'\nSERVICE_ACC_RE = re.compile(r'\\d{6,}')        # simplistic service account numeric pattern\n\ndef perform_transfers_and_audit(bank_manager, transfers):\n    \"\"\"\n    Application flow that must:\n     - Call CheckAuthorization once before the first sensitive action.\n     - Perform transfers.\n     - Create an audit events list (one batch) that does NOT include raw sensitive data.\n     - Call RecordAuditEvent(events) once at the end.\n    This function masks known sensitive patterns before adding to audit events.\n    \"\"\"\n    # 1) Authorization check\n    authorized = bank_manager.CheckAuthorization()\n    if not authorized:\n        raise PermissionError(\"Not authorized\")\n\n    events = []\n    for tx in transfers:\n        # Perform transfer\n        res = bank_manager.TransferFunds(\n            from_account_number=tx['from'],\n            to_account_number=tx['to'],\n            amount=tx['amount']\n        )\n        if not res:\n            # record a generic failure event\n            events.append(\"transfer_failed\")\n            continue\n\n        # Add events: intentionally include duplicates to ensure duplicates are recorded\n        # But sanitize any sensitive values before appending\n        # We'll use a simple masking function that hides account numbers / payee ids\n        def mask_sensitive(s):\n            s = ACCOUNT_RE.sub('XXX-XXXX-XXXX', s)\n            s = PAYEE_ID_RE.sub('P-XXXXXX', s)\n            s = SERVICE_ACC_RE.sub('******', s)\n            return s\n\n        # Example event messages (they must be sanitized)\n        raw_event1 = f\"transfer_initiated from {tx['from']} to {tx['to']}\"\n        raw_event2 = f\"transfer_completed amount={tx['amount']} service_acc={tx.get('service_account_number','')}\"\n        events.append(mask_sensitive(raw_event1))\n        events.append(mask_sensitive(raw_event2))\n        # Add an extra duplicate event to ensure duplicates are preserved\n        events.append(\"transfer_completed\")  # generic duplicate\n\n    # Record all audit events once, at the end\n    bank_manager.RecordAuditEvent(events)\n    return events\n\n\nclass TestBankManagerAuditPolicy(unittest.TestCase):\n    def test_authorization_before_transfers_and_no_sensitive_in_audit(self):\n        # Create a mock BankManager\n        bm = Mock()\n\n        # Mock behaviors: CheckAuthorization -> True, TransferFunds -> True, RecordAuditEvent -> returns id\n        bm.CheckAuthorization.return_value = True\n        bm.TransferFunds.return_value = True\n        bm.RecordAuditEvent.return_value = \"log-batch-123\"\n\n        # Two transfers to same payee to produce duplicate events\n        transfers = [\n            {\n                'from': '123-4567-8901',\n                'to': '999-8888-7777',\n                'amount': 150.00,\n                'service_account_number': '123456'\n            },\n            {\n                'from': '123-4567-8901',\n                'to': '999-8888-7777',\n                'amount': 200.00,\n                'service_account_number': '123456'\n            }\n        ]\n\n        events = perform_transfers_and_audit(bm, transfers)\n\n        # 1) Ensure CheckAuthorization was called once and before any TransferFunds call\n        self.assertTrue(bm.CheckAuthorization.called, \"CheckAuthorization must be called\")\n        # Check call order: first call should be CheckAuthorization\n        first_call = bm.mock_calls[0]\n        self.assertEqual(first_call[0], \"CheckAuthorization\")\n\n        # Ensure TransferFunds was called for each transfer\n        expected_transfer_calls = [\n            call.TransferFunds(from_account_number='123-4567-8901', to_account_number='999-8888-7777', amount=150.0),\n            call.TransferFunds(from_account_number='123-4567-8901', to_account_number='999-8888-7777', amount=200.0),\n        ]\n        self.assertEqual(bm.method_calls[1:3], expected_transfer_calls)\n\n        # 2) Ensure RecordAuditEvent was called exactly once with a list argument\n        bm.RecordAuditEvent.assert_called_once()\n        recorded_args = bm.RecordAuditEvent.call_args[0]\n        self.assertEqual(len(recorded_args), 1, \"RecordAuditEvent should be called with one positional argument (events list)\")\n        recorded_events = recorded_args[0]\n        self.assertIsInstance(recorded_events, list, \"RecordAuditEvent must be called with a list\")\n\n        # 3) Verify that every occurrence is recorded (we expect 3 events per transfer in our flow => 6 total)\n        self.assertEqual(len(recorded_events), 6, f\"Expected 6 audit events recorded, got {len(recorded_events)}\")\n\n        # 4) Verify no raw account numbers, payee ids, or service account numbers are present in recorded events\n        for e in recorded_events:\n            self.assertFalse(ACCOUNT_RE.search(e),\n                             f\"Audit event contains raw account number: {e}\")\n            self.assertFalse(PAYEE_ID_RE.search(e),\n                             f\"Audit event contains raw payee id: {e}\")\n            # service account numbers are numeric sequences; check to ensure not present (simplistic)\n            self.assertFalse(SERVICE_ACC_RE.search(e),\n                             f\"Audit event contains raw service account or numeric sequence: {e}\")\n\n        # 5) Verify duplicates are preserved (we appended \"transfer_completed\" duplicates)\n        completed_count = sum(1 for ev in recorded_events if \"transfer_completed\" in ev)\n        self.assertGreaterEqual(completed_count, 2, \"Duplicate events should be recorded (at least one duplicate expected)\")\n\n        # Optional: ensure RecordAuditEvent returned a batch id (as per API)\n        log_id = bm.RecordAuditEvent.return_value\n        self.assertIsInstance(log_id, str)\n\nif __name__ == '__main__':\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent",
      "TransferFunds",
      "TransferFunds"
    ]
  },
  {
    "iteration": 10,
    "code": "import unittest\n\n# Simulate the API exception described in the toolkit spec\nclass InvalidRequestException(Exception):\n    pass\n\n# Minimal fake implementation of the BankManager.RecordAuditEvent following the API doc\nclass FakeBankManager:\n    def RecordAuditEvent(self, events=None):\n        \"\"\"\n        Records a batch of security-relevant events to the system's audit log.\n        Raises InvalidRequestException if 'events' is missing, empty, or not a list.\n        Returns a dict with 'log_entry_id' on success.\n        \"\"\"\n        # API doc: events is required, must be a non-empty list\n        if events is None or not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter is missing, empty, or not a list.\")\n        # In a real implementation, there would be more validation/processing.\n        # Return a fake unique identifier for the recorded batch.\n        return {\"log_entry_id\": \"LOG-20251222-0001\"}\n\nclass RecordAuditEventTests(unittest.TestCase):\n    def setUp(self):\n        # Create an instance of the fake BankManager for testing\n        self.client = FakeBankManager()\n\n    def test_record_audit_event_empty_list_raises_invalid_request(self):\n        \"\"\"\n        Verify that calling RecordAuditEvent with an empty list raises InvalidRequestException.\n\n        Policy being tested (from API spec):\n        - RecordAuditEvent should raise InvalidRequestException when the 'events'\n          parameter is missing, empty, or not a list.\n        \"\"\"\n        with self.assertRaises(InvalidRequestException) as cm:\n            self.client.RecordAuditEvent(events=[])\n        # Optionally assert on the exception message to ensure correct rejection reason\n        self.assertIn(\"missing, empty, or not a list\", str(cm.exception))\n\n    # (Optional) demonstrate the positive case to ensure valid input succeeds\n    def test_record_audit_event_with_valid_events_returns_log_id(self):\n        \"\"\"\n        Small positive test: valid non-empty list should return a log_entry_id.\n        This helps ensure the validation isn't overly restrictive.\n        \"\"\"\n        events = [\"LOGIN_SUCCESS\", \"TRANSFER_INITIATED\", \"TRANSFER_COMPLETED\"]\n        result = self.client.RecordAuditEvent(events=events)\n        self.assertIsInstance(result, dict)\n        self.assertIn(\"log_entry_id\", result)\n        self.assertTrue(isinstance(result[\"log_entry_id\"], str) and len(result[\"log_entry_id\"]) > 0)\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 11,
    "code": "# test_bankmanager_authorization.py\n\"\"\"\nTest case: verify that sensitive actions (fund transfer) are only performed after\nauthorization is confirmed, and that audit events are recorded at the end of the\nsession/sequence.\n\nThis maps to the toolkit guidance that CheckAuthorization() should be called once\nbefore the first sensitive action, and to secure practice that unauthorized\nattempts are blocked and audited.\n\"\"\"\n\nimport unittest\nfrom unittest.mock import Mock, call\n\n\ndef perform_transfer_flow(bank_manager, from_acc, to_acc, amount):\n    \"\"\"\n    Helper that implements the expected secure transfer flow:\n      1. Call CheckAuthorization() once before performing a sensitive action.\n      2. If not authorized, record an audit event and raise PermissionError.\n      3. If authorized, call TransferFunds() and record audit events at the end.\n    \"\"\"\n    # 1. Authorization\n    authorized = bank_manager.CheckAuthorization()\n    if not authorized:\n        # 2. Unauthorized: record the audit event and block transfer\n        bank_manager.RecordAuditEvent(events=[\n            \"transfer_attempt_unauthorized\",\n            f\"from:{from_acc}\",\n            f\"to:{to_acc}\",\n            f\"amount:{amount}\"\n        ])\n        raise PermissionError(\"Session is not authorized to perform transfers.\")\n\n    # 3. Authorized: perform transfer\n    result = bank_manager.TransferFunds(\n        from_account_number=from_acc,\n        to_account_number=to_acc,\n        amount=amount\n    )\n    # Normalize return shape (some implementations return dict with 'success', some boolean)\n    success = result.get(\"success\") if isinstance(result, dict) else result\n\n    # Record audit events for the successful attempt (even if failed, record attempt)\n    events = [\n        \"transfer_attempt\",\n        f\"from:{from_acc}\",\n        f\"to:{to_acc}\",\n        f\"amount:{amount}\",\n        \"transfer_success\" if success else \"transfer_failed\"\n    ]\n    bank_manager.RecordAuditEvent(events=events)\n\n    return success\n\n\nclass TestBankManagerAuthorization(unittest.TestCase):\n    def test_transfer_requires_authorization_and_records_audit(self):\n        # Create a mock BankManager client\n        bm = Mock(name=\"BankManager\")\n\n        # Configure CheckAuthorization to return False on first call (unauth attempt)\n        # and True on second call (authorized attempt)\n        bm.CheckAuthorization.side_effect = [False, True]\n\n        # Configure TransferFunds to return a dictionary with success True\n        bm.TransferFunds.return_value = {\"success\": True}\n\n        # Configure RecordAuditEvent to return a fake log id\n        bm.RecordAuditEvent.return_value = {\"log_entry_id\": \"log-abc-123\"}\n\n        from_acc = \"123-4567-8901\"\n        to_acc = \"321-7654-0987\"\n        amount = 250.00\n\n        # --- Unauthorized attempt: should be blocked and audited ---\n        with self.assertRaises(PermissionError):\n            perform_transfer_flow(bm, from_acc, to_acc, amount)\n\n        # TransferFunds must NOT have been called for the unauthorized attempt\n        bm.TransferFunds.assert_not_called()\n\n        # RecordAuditEvent should have been called once to log the unauthorized attempt\n        bm.RecordAuditEvent.assert_called_with(events=[\n            \"transfer_attempt_unauthorized\",\n            f\"from:{from_acc}\",\n            f\"to:{to_acc}\",\n            f\"amount:{amount}\"\n        ])\n\n        # Reset mocks' call history for clarity of subsequent assertions\n        bm.RecordAuditEvent.reset_mock()\n        bm.TransferFunds.reset_mock()\n\n        # --- Authorized attempt: should proceed and be audited ---\n        success = perform_transfer_flow(bm, from_acc, to_acc, amount)\n        self.assertTrue(success)\n\n        # TransferFunds should have been called once with correct parameters\n        bm.TransferFunds.assert_called_once_with(\n            from_account_number=from_acc,\n            to_account_number=to_acc,\n            amount=amount\n        )\n\n        # RecordAuditEvent should have been called once to log the attempt+result\n        bm.RecordAuditEvent.assert_called_once()\n        recorded_events = bm.RecordAuditEvent.call_args[1][\"events\"]\n        # Basic checks on the recorded events\n        self.assertIn(\"transfer_attempt\", recorded_events)\n        self.assertIn(f\"from:{from_acc}\", recorded_events)\n        self.assertIn(f\"to:{to_acc}\", recorded_events)\n        self.assertIn(f\"amount:{amount}\", recorded_events)\n        self.assertIn(\"transfer_success\", recorded_events)\n\n        # Also verify CheckAuthorization was indeed called twice across both flows\n        self.assertEqual(bm.CheckAuthorization.call_count, 2)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 12,
    "code": "\"\"\"\nTest: Verify that the BankManager enforces pre-action authorization and that RecordAuditEvent\ncaptures every occurrence (including duplicates) and rejects invalid input.\n\nThis single unittest covers the following safety/behavior expectations:\n- CheckAuthorization should be called once before the first sensitive action in a session.\n- RecordAuditEvent must accept a non-empty list of event strings, preserve duplicates,\n  return a log_entry_id string, and raise InvalidRequestException for missing/empty/invalid input.\n\nThe test uses a local FakeBankManager implementing the documented API semantics and exceptions.\n\"\"\"\n\nimport re\nimport unittest\nimport uuid\n\n\n# Exceptions as described by the API\nclass InvalidRequestException(Exception):\n    pass\n\n\nclass UnauthorizedSessionException(Exception):\n    pass\n\n\nclass FakeBankManager:\n    \"\"\"\n    Minimal in-memory fake implementation of the BankManager toolkit for testing.\n    Tracks number of CheckAuthorization calls, enforces authorization before sensitive actions,\n    and implements RecordAuditEvent semantics (reject empty/non-list, preserve duplicates).\n    \"\"\"\n    ACCOUNT_RE = re.compile(r\"^\\d{3}-\\d{4}-\\d{4}$\")\n    PAYEE_RE = re.compile(r\"^P-\\d{6}$\")\n\n    def __init__(self):\n        self.authorized = False\n        self.checkauth_called_count = 0\n        self.audit_store = {}  # log_entry_id -> events list\n        self.last_log_entry_id = \"\"\n\n    def CheckAuthorization(self):\n        self.checkauth_called_count += 1\n        # For testing we always authorize\n        self.authorized = True\n        return {\"authorized\": True}\n\n    def _ensure_authorized(self):\n        if not self.authorized:\n            raise UnauthorizedSessionException(\"CheckAuthorization must be called before performing sensitive actions\")\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        self._ensure_authorized()\n        if not (isinstance(from_account_number, str) and isinstance(to_account_number, str)):\n            raise InvalidRequestException(\"Account numbers must be strings\")\n        if not (self.ACCOUNT_RE.match(from_account_number) and self.ACCOUNT_RE.match(to_account_number)):\n            raise InvalidRequestException(\"Account number(s) not in correct format\")\n        if amount is None or not (isinstance(amount, (int, float)) and amount > 0):\n            raise InvalidRequestException(\"Amount must be positive\")\n        # Simulate success\n        return {\"success\": True}\n\n    def PayBill(self, from_account_number, payee_id, service_account_number, payment_date, amount):\n        self._ensure_authorized()\n        if not self.ACCOUNT_RE.match(from_account_number):\n            raise InvalidRequestException(\"from_account_number not in correct format\")\n        if not self.PAYEE_RE.match(payee_id):\n            raise InvalidRequestException(\"payee_id invalid\")\n        if amount is None or not (isinstance(amount, (int, float)) and amount > 0):\n            raise InvalidRequestException(\"Amount must be positive\")\n        # payment_date and service_account_number format checks omitted for brevity\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Validate input\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n        # Ensure each event is a string\n        if not all(isinstance(e, str) and e for e in events):\n            raise InvalidRequestException(\"All events must be non-empty strings.\")\n        log_entry_id = uuid.uuid4().hex\n        # store events including duplicates\n        self.audit_store[log_entry_id] = list(events)\n        self.last_log_entry_id = log_entry_id\n        return {\"log_entry_id\": log_entry_id}\n\n\nclass TestBankManagerAuditAndAuthorization(unittest.TestCase):\n    def setUp(self):\n        self.manager = FakeBankManager()\n\n    def test_authorization_before_sensitive_actions_and_audit_event_logging(self):\n        # 1) Attempting a sensitive action without authorization should fail\n        with self.assertRaises(UnauthorizedSessionException):\n            self.manager.TransferFunds(\"123-4567-8901\", \"222-3333-4444\", 50.0)\n\n        # 2) Call CheckAuthorization once before first sensitive action\n        auth_resp = self.manager.CheckAuthorization()\n        self.assertIsInstance(auth_resp, dict)\n        self.assertTrue(auth_resp.get(\"authorized\"))\n        self.assertEqual(self.manager.checkauth_called_count, 1, \"CheckAuthorization should be called exactly once so far\")\n\n        # 3) Perform two transfers and one bill payment (note duplicate TransferFunds event)\n        t1 = self.manager.TransferFunds(\"123-4567-8901\", \"222-3333-4444\", 100.0)\n        self.assertTrue(t1[\"success\"])\n        pay = self.manager.PayBill(\"123-4567-8901\", \"P-000001\", \"SA-100\", \"2025-12-31\", 25.50)\n        self.assertTrue(pay[\"success\"])\n        t2 = self.manager.TransferFunds(\"123-4567-8901\", \"333-4444-5555\", 40.0)\n        self.assertTrue(t2[\"success\"])\n\n        # Check authorization still only required once and count remains 1\n        self.assertEqual(self.manager.checkauth_called_count, 1, \"CheckAuthorization should not need to be called again for subsequent actions in same session\")\n\n        # 4) Record audit events including duplicates and verify stored events are preserved exactly\n        events_list = [\"TransferFunds\", \"PayBill\", \"TransferFunds\"]\n        record_resp = self.manager.RecordAuditEvent(events_list)\n        self.assertIn(\"log_entry_id\", record_resp)\n        log_id = record_resp[\"log_entry_id\"]\n        self.assertIsInstance(log_id, str)\n        self.assertTrue(len(log_id) > 0)\n        # verify audit store contains the exact list (including duplicates and order)\n        self.assertIn(log_id, self.manager.audit_store)\n        self.assertEqual(self.manager.audit_store[log_id], events_list)\n\n        # 5) Calling RecordAuditEvent with an empty list should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.manager.RecordAuditEvent([])\n\n        # 6) Calling RecordAuditEvent with non-list should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.manager.RecordAuditEvent(\"Not a list\")\n\n        # 7) Calling RecordAuditEvent with invalid event element should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.manager.RecordAuditEvent([\"TransferFunds\", \"\", 123])\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)",
    "extracted_trace": [
      "TransferFunds",
      "CheckAuthorization",
      "TransferFunds",
      "PayBill",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 13,
    "code": "# test_bank_audit_obfuscation.py\n# Pytest test to verify audit logging does not contain sensitive account numbers\n#\n# Scenario:\n# - User is authorized (CheckAuthorization returns True).\n# - A funds transfer is performed via TransferFunds.\n# - The application must record audit events at the end of the sequence.\n# - Audit events must not contain full account numbers (logs must avoid sensitive payment data).\n#\n# This test builds a small helper that performs the transfer and logs an obfuscated audit event,\n# then asserts that RecordAuditEvent was called with events that do not contain the raw account numbers.\n\nimport pytest\nfrom unittest.mock import MagicMock\n\n# Simulated API exception described in the API doc\nclass InvalidRequestException(Exception):\n    pass\n\ndef obfuscate_account(account_number: str) -> str:\n    \"\"\"\n    Obfuscate a bank account number preserving only the last 4 digits.\n    Expected account format (per API): 'XXX-XXXX-XXXX' but this function will handle generic strings.\n    Example: '001-2345-6789' -> '***-****-6789'\n    \"\"\"\n    if not isinstance(account_number, str):\n        return 'REDACTED'\n    # Keep last 4 chars (digits) and replace the rest with '*'\n    tail = account_number[-4:]\n    # keep separators in tail if present in original; simple mask for the rest\n    masked_prefix = '*' * max(0, len(account_number) - 4)\n    return masked_prefix + tail\n\ndef perform_transfer_and_record_audit(bank_manager, from_account, to_account, amount):\n    \"\"\"\n    High-level operation that:\n    1) Confirms authorization via CheckAuthorization\n    2) Initiates TransferFunds\n    3) Records an audit event with obfuscated account numbers\n    \"\"\"\n    auth = bank_manager.CheckAuthorization()\n    if not auth.get('authorized', False):\n        raise PermissionError(\"Session is not authorized for sensitive actions\")\n\n    transfer_result = bank_manager.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount\n    )\n    if not transfer_result.get('success', False):\n        raise RuntimeError(\"Transfer failed\")\n\n    # Build audit event while ensuring sensitive fields are obfuscated\n    from_obf = obfuscate_account(from_account)\n    to_obf = obfuscate_account(to_account)\n    event = f\"TRANSFER_COMPLETED from={from_obf} to={to_obf} amount={amount}\"\n    # As per API, RecordAuditEvent expects a list of strings\n    audit_resp = bank_manager.RecordAuditEvent(events=[event])\n    return audit_resp\n\ndef test_transfer_audit_events_do_not_contain_sensitive_account_numbers():\n    # Arrange: create a mock BankManager with the required behaviors\n    bank_manager = MagicMock(name=\"BankManagerMock\")\n\n    # Mock CheckAuthorization to simulate an authorized session\n    bank_manager.CheckAuthorization.return_value = {'authorized': True}\n\n    # Mock TransferFunds to simulate a successful transfer\n    bank_manager.TransferFunds.return_value = {'success': True}\n\n    # Implement RecordAuditEvent behavior:\n    # - If events is missing/empty/not a list -> raise InvalidRequestException\n    # - Otherwise return a fake log_entry_id\n    def record_audit_side_effect(events):\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n        # Also assert inside the side effect that sensitive-looking account patterns are not present,\n        # to simulate the logging service rejecting events that contain full account numbers.\n        # (This models an additional safeguard against logging sensitive payment data)\n        joined = \" \".join(events)\n        # naive pattern for full account numbers as per API: three groups of digits with dashes (e.g., 'XXX-XXXX-XXXX')\n        import re\n        if re.search(r'\\b\\d{3}-\\d{4}-\\d{4}\\b', joined):\n            # If a full account-like pattern is detected in the event string, raise to indicate policy violation\n            raise InvalidRequestException(\"Audit event contains sensitive account numbers\")\n        return {'log_entry_id': 'log-abc-123'}\n\n    bank_manager.RecordAuditEvent.side_effect = record_audit_side_effect\n\n    # Example full account numbers (these match the API format)\n    from_account = \"123-4567-8901\"\n    to_account = \"987-6543-2100\"\n    amount = 250.00\n\n    # Act: perform the high-level transfer + audit action\n    resp = perform_transfer_and_record_audit(bank_manager, from_account, to_account, amount)\n\n    # Assert: RecordAuditEvent was called once and returned a log id\n    bank_manager.RecordAuditEvent.assert_called_once()\n    assert resp.get('log_entry_id') == 'log-abc-123'\n\n    # Additionally, verify that the recorded event does not contain the raw account numbers\n    called_args = bank_manager.RecordAuditEvent.call_args.args\n    assert len(called_args) == 1\n    events_logged = called_args[0]\n    # There should be at least one event and it should be a list\n    assert isinstance(events_logged, list) and len(events_logged) >= 1\n    events_concatenated = \" \".join(events_logged)\n\n    # The raw full account numbers must not appear in the logged events\n    assert from_account not in events_concatenated\n    assert to_account not in events_concatenated\n\n    # And the events should contain only obfuscated forms (endings of last-4 digits present)\n    assert from_account[-4:] in events_concatenated\n    assert to_account[-4:] in events_concatenated\n\n    # If all assertions pass, the test verifies that the application:\n    # - Calls authorization first,\n    # - Performs the transfer,\n    # - Records audit events,\n    # - And importantly, does not include sensitive account numbers in logs (aligns with ASVS logging/privacy policies).\n",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 14,
    "code": "import re\nimport uuid\nfrom datetime import datetime, timedelta\nimport pytest\n\n# Simple exception type the API docs mention\nclass InvalidRequestException(Exception):\n    pass\n\n# Minimal in-memory mock implementation of the BankManager API matching the provided spec.\nclass BankManagerMock:\n    ACCOUNT_NUM_PATTERN = re.compile(r'^\\d{3}-\\d{4}-\\d{4}$')\n\n    def __init__(self):\n        # Accounts owned by the authenticated user (for validation)\n        self.owned_accounts = {\n            '123-4567-8901': {\n                'account_number': '123-4567-8901',\n                'type': 'checking',\n                'balance': 2000.00,\n                'status': 'active'\n            },\n        }\n        # Ledger of transactions per account (list of dicts)\n        self.transactions = {acct: [] for acct in self.owned_accounts}\n        # For audit events\n        self.audit_logs = []\n\n    # CheckAuthorization: returns a simple boolean result\n    def CheckAuthorization(self):\n        return {'authorized': True}\n\n    # TransferFunds: validates inputs and records a debit for from_account and a credit for to_account (if owned)\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        # Validate formats\n        if not self.ACCOUNT_NUM_PATTERN.match(from_account_number) or not self.ACCOUNT_NUM_PATTERN.match(to_account_number):\n            raise InvalidRequestException(\"Account number format invalid.\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive.\")\n        # Validate ownership of from_account\n        if from_account_number not in self.owned_accounts:\n            raise InvalidRequestException(\"From account is not owned by the user.\")\n        # Perform transfer (mock behavior): debit from_account\n        timestamp = datetime.utcnow().strftime('%Y-%m-%d')\n        debit_tx = {\n            'date': timestamp,\n            'description': f'Transfer to {to_account_number}',\n            'amount': -amount,  # debit as negative amount\n            'balance': round(self.owned_accounts[from_account_number]['balance'] - amount, 2)\n        }\n        self.owned_accounts[from_account_number]['balance'] = debit_tx['balance']\n        self.transactions[from_account_number].append(debit_tx)\n        # If to_account is also owned locally, credit it\n        if to_account_number in self.owned_accounts:\n            credit_tx = {\n                'date': timestamp,\n                'description': f'Transfer from {from_account_number}',\n                'amount': amount,\n                'balance': round(self.owned_accounts[to_account_number]['balance'] + amount, 2)\n            }\n            self.owned_accounts[to_account_number]['balance'] = credit_tx['balance']\n            self.transactions[to_account_number].append(credit_tx)\n        # Return success\n        return {'success': True}\n\n    # SearchTransactions: filter transactions by account_number and optional keyword or amount range\n    def SearchTransactions(self, account_number, keyword=None, min_amount=None, max_amount=None):\n        if not self.ACCOUNT_NUM_PATTERN.match(account_number):\n            raise InvalidRequestException(\"Account number format invalid.\")\n        if account_number not in self.transactions:\n            # No transactions for unknown account (but still valid format)\n            return {'transactions': []}\n        results = []\n        for tx in self.transactions[account_number]:\n            if keyword:\n                if keyword.lower() not in tx['description'].lower():\n                    continue\n            if (min_amount is not None) and (tx['amount'] < min_amount):\n                continue\n            if (max_amount is not None) and (tx['amount'] > max_amount):\n                continue\n            results.append(tx)\n        return {'transactions': results}\n\n    # GetAccountStatement: return transaction list between dates (dates inclusive). download ignored for the mock\n    def GetAccountStatement(self, account_number, start_date, end_date, download=False):\n        if not self.ACCOUNT_NUM_PATTERN.match(account_number):\n            raise InvalidRequestException(\"Account number format invalid.\")\n        if account_number not in self.transactions:\n            return {'transactions': [], 'statement_file_path': ''}\n        # parse dates\n        sd = datetime.strptime(start_date, '%Y-%m-%d').date()\n        ed = datetime.strptime(end_date, '%Y-%m-%d').date()\n        filtered = []\n        for tx in self.transactions[account_number]:\n            tx_date = datetime.strptime(tx['date'], '%Y-%m-%d').date()\n            if sd <= tx_date <= ed:\n                filtered.append(tx)\n        return {'transactions': filtered, 'statement_file_path': ''}\n\n    # RecordAuditEvent: expects non-empty list\n    def RecordAuditEvent(self, events):\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"Events must be a non-empty list.\")\n        entry_id = str(uuid.uuid4())\n        self.audit_logs.append({'id': entry_id, 'events': events, 'timestamp': datetime.utcnow().isoformat()})\n        return {'log_entry_id': entry_id}\n\n\n# The actual test verifying Article 66(3)(h): the system must not modify amount or payee\ndef test_transfer_does_not_modify_amount_or_payee():\n    bank = BankManagerMock()\n\n    # 1) Session authorization check (as required once before sensitive actions)\n    auth = bank.CheckAuthorization()\n    assert auth.get('authorized') is True, \"Session must be authorized before making transfers\"\n\n    # Test scenario data\n    from_account = '123-4567-8901'  # owned by the mock user\n    to_account = '999-8888-7777'    # external account (not owned locally)\n    transfer_amount = 150.00\n\n    # 2) Perform the transfer\n    transfer_result = bank.TransferFunds(from_account_number=from_account,\n                                         to_account_number=to_account,\n                                         amount=transfer_amount)\n    assert transfer_result.get('success') is True, \"TransferFunds should report success for valid transfer\"\n\n    # 3) Search transactions on the from_account to find the debit corresponding to the transfer\n    # We search for transactions with amount equal to -transfer_amount (debit)\n    search_resp = bank.SearchTransactions(account_number=from_account,\n                                          min_amount=-transfer_amount - 0.0001,\n                                          max_amount=-transfer_amount + 0.0001)\n    transactions = search_resp.get('transactions', [])\n    assert len(transactions) >= 1, f\"No transaction matching the debit of {transfer_amount} found on {from_account}\"\n\n    # Pick the most recent matching transaction\n    tx = transactions[-1]\n\n    # 4) Assertions ensuring the system did not modify the key features:\n    # - amount must match exactly the requested amount (as a debit: negative)\n    assert abs(tx['amount']) == pytest.approx(transfer_amount, rel=1e-9), \\\n        f\"Executed transaction amount {tx['amount']} does not match requested {transfer_amount}\"\n\n    # - payee / description should reference the requested to_account (payee) \u2014 check presence\n    assert to_account in tx['description'], \\\n        f\"Transaction description does not reference target payee {to_account}: {tx['description']}\"\n\n    # 5) Record audit events at the end of the sequence (API request in docs to call once at end)\n    events = [\n        'check_authorization',\n        f'transfer_from:{from_account}_to:{to_account}_amount:{transfer_amount}',\n        'search_transactions',\n        'get_statement_or_audit'\n    ]\n    audit_resp = bank.RecordAuditEvent(events=events)\n    log_id = audit_resp.get('log_entry_id')\n    assert isinstance(log_id, str) and log_id, \"RecordAuditEvent should return a non-empty log_entry_id\"\n\n    # If we reach here, the transfer preserved amount and payee as required by the policy",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "SearchTransactions",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 15,
    "code": "import pytest\nimport uuid\n\n# --- Mock/Stub classes that mirror the API described in the doc ---\n\nclass InvalidRequestException(Exception):\n    \"\"\"Raised when the request is invalid according to API doc for RecordAuditEvent.\"\"\"\n    pass\n\nclass MockBankManager:\n    \"\"\"\n    A minimal in-memory mock of the BankManager toolkit methods needed for the test.\n    Implements CheckAuthorization and RecordAuditEvent with behavior described in the API doc.\n    \"\"\"\n    def __init__(self):\n        self.authorized = True\n        self._last_recorded_batches = []  # store the batches (including duplicates) for assertions\n\n    def CheckAuthorization(self):\n        # According to doc: should be called once before first sensitive action.\n        # Returns { \"authorized\": boolean }\n        return {\"authorized\": self.authorized}\n\n    def RecordAuditEvent(self, events=None):\n        # Validate parameter as per API doc and raise InvalidRequestException if invalid\n        if events is None or not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n\n        # Record the batch exactly as provided (including duplicates)\n        batch_id = f\"log-{uuid.uuid4()}\"\n        self._last_recorded_batches.append({\"id\": batch_id, \"events\": list(events)})\n        return {\"log_entry_id\": batch_id}\n\n# --- Test case ---\ndef test_record_audit_event_rejects_empty_and_preserves_duplicates():\n    \"\"\"\n    Scenario (varied):\n      - Ensure authorization is checked before sensitive actions.\n      - Attempt to record an empty audit events list -> expect InvalidRequestException.\n      - Record a valid batch containing duplicate event strings -> expect success and duplicates preserved.\n    Policy verified:\n      - RecordAuditEvent must reject missing/empty/non-list 'events' (InvalidRequestException).\n      - The system must capture every individual occurrence of an event, including duplicates.\n    \"\"\"\n    bm = MockBankManager()\n\n    # 1) Check authorization before sensitive action\n    auth = bm.CheckAuthorization()\n    assert isinstance(auth, dict) and auth.get(\"authorized\") is True, \"Session must be authorized before sensitive actions.\"\n\n    # 2) Call RecordAuditEvent with an empty list -> should raise InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent(events=[])\n\n    # 3) Call RecordAuditEvent with a valid list containing duplicates -> should return a log_entry_id\n    events_with_duplicates = [\"LOGIN\", \"TRANSFER\", \"TRANSFER\", \"LOGOUT\"]\n    resp = bm.RecordAuditEvent(events=events_with_duplicates)\n\n    # Validate response shape\n    assert isinstance(resp, dict) and \"log_entry_id\" in resp and isinstance(resp[\"log_entry_id\"], str)\n\n    # Validate the mock recorded exactly what was passed (duplicates preserved)\n    assert len(bm._last_recorded_batches) == 1\n    recorded = bm._last_recorded_batches[0]\n    assert recorded[\"events\"] == events_with_duplicates, \"All event occurrences (including duplicates) must be stored.\"\n\nif __name__ == \"__main__\":\n    # Run the test directly when executing the file\n    pytest.main([__file__])",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 16,
    "code": "# test_audit_event_validation.py\n# Pytest test verifying that RecordAuditEvent enforces the \"events\" parameter rules:\n# - must be provided,\n# - must be a non-empty list.\n#\n# This corresponds to the toolkit contract which declares RecordAuditEvent raises\n# InvalidRequestException when 'events' is missing, empty, or not a list.\n# (Policy-level expectation: audit logging API must validate inputs and reject invalid requests.)\n\nimport pytest\n\n# Replace this import with the real BankManager SDK/module available in your test environment.\n# The API doc describes a toolkit named \"BankManager\" exposing CheckAuthorization and RecordAuditEvent,\n# and an exception type InvalidRequestException for invalid requests.\ntry:\n    from BankManager import BankManager, InvalidRequestException\nexcept ImportError:\n    # If the concrete SDK is not available in the environment running the test, fail early with a clear message.\n    raise RuntimeError(\"BankManager SDK not available. Install or provide the BankManager test double to run this test.\")\n\n\ndef test_record_audit_event_requires_non_empty_list():\n    \"\"\"\n    Test scenario:\n      - Ensure session is authorized (recommended by the toolkit: call CheckAuthorization before sensitive actions).\n      - Call RecordAuditEvent with invalid inputs and expect InvalidRequestException:\n          * empty list []\n          * non-list value (string)\n      - Call RecordAuditEvent with a valid list containing duplicates and expect a successful response\n        including a non-empty 'log_entry_id' string (duplicates must be accepted and recorded).\n    \"\"\"\n\n    client = BankManager()\n\n    # 1) Ensure authorization is present. If the API requires calling CheckAuthorization before\n    # sensitive operations, we do that here. If unauthorized, abort the test with a clear reason.\n    auth = client.CheckAuthorization()\n    assert isinstance(auth, dict) or hasattr(auth, 'authorized'), \"Unexpected CheckAuthorization return type\"\n    # accommodate both dict or object return styles:\n    authorized = auth.get('authorized') if isinstance(auth, dict) else getattr(auth, 'authorized')\n    assert authorized is True, \"Test session is not authorized; RecordAuditEvent may not be allowed.\"\n\n    # 2) Invalid: empty list must raise InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        client.RecordAuditEvent(events=[])\n\n    # 3) Invalid: non-list (e.g., a string) must raise InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        client.RecordAuditEvent(events=\"TRANSFER\")  # wrong type\n\n    # 4) Valid: a non-empty list with duplicates should succeed and return a 'log_entry_id'\n    valid_events = [\"TRANSFER_INITIATED\", \"TRANSFER_INITIATED\", \"PAYMENT_FAILURE\"]\n    result = client.RecordAuditEvent(events=valid_events)\n\n    # Accepting either dict-like or object-like return:\n    if isinstance(result, dict):\n        log_entry_id = result.get('log_entry_id')\n    else:\n        log_entry_id = getattr(result, 'log_entry_id', None)\n\n    assert isinstance(log_entry_id, str) and log_entry_id.strip(), \"Expected non-empty log_entry_id string on success\"\n\n    # Optionally: additional lightweight sanity check that duplicates are allowed (we expect success above).\n    # If the SDK exposes more detail about recorded events, more assertions could be added here.\n\n# To run:\n#   pytest -q test_audit_event_validation.py\n#\n# Notes:\n# - This test focuses on input validation behavior of the RecordAuditEvent API and the presence of the\n#   InvalidRequestException per the API contract / safety policy.\n# - Adjust import paths and exception names if your BankManager SDK exposes them under different module names.",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 17,
    "code": "import unittest\nfrom uuid import uuid4\n\n# --- Fake/minimal BankManager implementation matching the API spec for testing purposes ---\nclass InvalidRequestException(Exception):\n    \"\"\"Raised when an API parameter is invalid (per API spec).\"\"\"\n    pass\n\nclass FakeBankManager:\n    def __init__(self):\n        self.authorized = False\n        self.last_audit_events = None\n\n    def CheckAuthorization(self):\n        # For testing, simulate an authorized session\n        self.authorized = True\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        # Validate format 'XXX-XXXX-XXXX' (simple check) and amount > 0 and require authorization\n        if not self.authorized:\n            raise InvalidRequestException(\"Session not authorized. Call CheckAuthorization() before sensitive actions.\")\n        def valid_acc(acc):\n            parts = acc.split('-')\n            return len(parts) == 3 and all(p.isdigit() for p in parts) and len(parts[0]) == 3 and len(parts[1]) == 4 and len(parts[2]) == 4\n\n        if not valid_acc(from_account_number) or not valid_acc(to_account_number):\n            raise InvalidRequestException(\"Account number not in 'XXX-XXXX-XXXX' format.\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive.\")\n        # Simulate success\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Enforce API contract: events must be a non-empty list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n        # Record exactly what is given (including duplicates)\n        self.last_audit_events = list(events)\n        # Return a unique batch id\n        return {\"log_entry_id\": f\"LOG-{uuid4()}\"}\n\n# --- Unit tests verifying the safety policy related to RecordAuditEvent ---\nclass TestRecordAuditEventPolicy(unittest.TestCase):\n    def setUp(self):\n        self.client = FakeBankManager()\n\n    def test_record_audit_event_invalid_inputs_raise(self):\n        \"\"\"RecordAuditEvent must reject missing/empty/non-list events parameter.\"\"\"\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent(None)  # missing / not a list\n\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent([])    # empty list\n\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent(\"login,transfer\")  # wrong type\n\n    def test_audit_events_must_capture_duplicates_and_called_once_at_end(self):\n        \"\"\"\n        Simulate a session:\n          - authorize\n          - perform the same transfer twice (duplicate action)\n          - call RecordAuditEvent exactly once with events that MUST include both occurrences (duplicates)\n        Verify:\n          - TransferFunds succeeds (requires prior CheckAuthorization)\n          - RecordAuditEvent returns a non-empty log_entry_id\n          - The recorded audit events preserve duplicates and order\n        \"\"\"\n        # Authorize session (per API guidance: call once before first sensitive action)\n        auth = self.client.CheckAuthorization()\n        self.assertTrue(auth.get(\"authorized\"), \"CheckAuthorization should return authorized=True in this test stub\")\n\n        # Perform two identical transfers (the same action occurs twice)\n        t1 = self.client.TransferFunds(\"123-4567-8901\", \"321-7654-0987\", 50.0)\n        self.assertTrue(t1.get(\"success\"))\n\n        t2 = self.client.TransferFunds(\"123-4567-8901\", \"321-7654-0987\", 25.0)\n        self.assertTrue(t2.get(\"success\"))\n\n        # Build audit events list capturing each occurrence (including duplicates)\n        events = [\n            \"TRANSFER_INITIATED:from=123-4567-8901:to=321-7654-0987:amount=50.0\",\n            \"TRANSFER_INITIATED:from=123-4567-8901:to=321-7654-0987:amount=25.0\"\n        ]\n\n        # Call RecordAuditEvent once at the end of the session (as required)\n        result = self.client.RecordAuditEvent(events)\n        log_id = result.get(\"log_entry_id\")\n        self.assertIsInstance(log_id, str)\n        self.assertTrue(len(log_id) > 0, \"RecordAuditEvent should return a non-empty log_entry_id\")\n\n        # Verify the internal audit store preserved the exact list (duplicates are maintained)\n        self.assertEqual(self.client.last_audit_events, events,\n                         \"Audit event list must capture every individual occurrence, including duplicates, in order.\")\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 18,
    "code": "#!/usr/bin/env python3\n\"\"\"\nTest case: Verify strong-customer-authentication requirement (policy Article 97)\napplied before initiating a remote payment transaction (TransferFunds), and that\nsecurity-relevant events are recorded via RecordAuditEvent at the end of the flow.\n\nThis test uses unittest + unittest.mock to simulate the BankManager toolkit.\nIt exercises two scenarios in a single test function:\n - authorized transfer (should call CheckAuthorization, TransferFunds, then RecordAuditEvent)\n - unauthorized attempt (should call CheckAuthorization, NOT call TransferFunds, but still RecordAuditEvent)\n\"\"\"\n\nimport unittest\nfrom unittest.mock import Mock, call\n\n\ndef secure_transfer(bank_manager, from_account, to_account, amount):\n    \"\"\"\n    Wrapper that enforces:\n      - CheckAuthorization must be called and return authorized=True before performing TransferFunds\n      - Records audit events exactly once at the end with each event occurrence.\n    This represents the expected behaviour to satisfy strong customer authentication\n    and audit logging policies.\n    \"\"\"\n    # 1) Authorization check\n    auth_resp = bank_manager.CheckAuthorization()\n    # auth_resp might be boolean or dict {'authorized': bool}\n    if isinstance(auth_resp, dict):\n        authorized = auth_resp.get(\"authorized\", False)\n    else:\n        authorized = bool(auth_resp)\n\n    events = []\n    events.append(\"AUTH_CHECK\")\n\n    if not authorized:\n        events.append(\"AUTH_FAILED\")\n        # Record audit and raise to signal forbidden operation\n        bank_manager.RecordAuditEvent(events)\n        raise PermissionError(\"Session not authorized to perform fund transfers\")\n\n    # 2) Perform transfer (sensitive action)\n    transfer_resp = bank_manager.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount,\n    )\n    # Expect transfer_resp possibly {'success': True} or similar\n    success = False\n    if isinstance(transfer_resp, dict):\n        success = bool(transfer_resp.get(\"success\"))\n    else:\n        success = bool(transfer_resp)\n\n    events.append(\"TRANSFER_FUNDS\")\n    # 3) Final audit event batch must be sent once\n    bank_manager.RecordAuditEvent(events)\n\n    return success\n\n\nclass TestStrongCustomerAuth(unittest.TestCase):\n    def test_transfer_requires_authorization_and_records_audit(self):\n        # Create a mock BankManager with the three methods we interact with\n        bm = Mock()\n        # Prepare return values for the \"authorized\" scenario first\n        bm.CheckAuthorization.return_value = {\"authorized\": True}\n        bm.TransferFunds.return_value = {\"success\": True}\n        bm.RecordAuditEvent.return_value = {\"log_entry_id\": \"log-123\"}\n\n        # Perform an authorized transfer\n        ok = secure_transfer(\n            bank_manager=bm,\n            from_account=\"123-4567-8901\",\n            to_account=\"999-8888-7777\",\n            amount=150.00,\n        )\n        self.assertTrue(ok, \"Expected transfer to report success when authorized\")\n\n        # Verify call order: CheckAuthorization -> TransferFunds -> RecordAuditEvent\n        expected_calls = [\n            call.CheckAuthorization(),\n            call.TransferFunds(\n                from_account_number=\"123-4567-8901\",\n                to_account_number=\"999-8888-7777\",\n                amount=150.00,\n            ),\n            call.RecordAuditEvent([\"AUTH_CHECK\", \"TRANSFER_FUNDS\"]),\n        ]\n        self.assertEqual(bm.method_calls, expected_calls)\n\n        # Reset mock to test unauthorized scenario (varying the scenario as requested)\n        bm.reset_mock()\n        bm.CheckAuthorization.return_value = {\"authorized\": False}\n        bm.RecordAuditEvent.return_value = {\"log_entry_id\": \"log-unauth-1\"}\n\n        # Unauthorized attempt must raise and must NOT call TransferFunds,\n        # but must call RecordAuditEvent once with an AUTH_FAILED event included.\n        with self.assertRaises(PermissionError):\n            secure_transfer(\n                bank_manager=bm,\n                from_account=\"123-4567-8901\",\n                to_account=\"000-1111-2222\",\n                amount=10.00,\n            )\n\n        # Verify calls for unauthorized flow\n        expected_calls_unauth = [\n            call.CheckAuthorization(),\n            # TransferFunds must NOT be called\n            call.RecordAuditEvent([\"AUTH_CHECK\", \"AUTH_FAILED\"]),\n        ]\n        self.assertEqual(bm.method_calls, expected_calls_unauth)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent",
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent",
      "CheckAuthorization",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 19,
    "code": "import re\nimport pytest\n\n# Custom exception matching the API's specification\nclass InvalidRequestException(Exception):\n    pass\n\n# Mock implementation of the BankManager API based on the provided API doc.\n# Replace this mock with the real client if available.\nclass MockBankManager:\n    def __init__(self):\n        # For the mock, assume accounts starting with '111' are owned by the user\n        self.owned_account_prefix = '111'\n\n    def CheckAuthorization(self):\n        # As required, called before first sensitive action\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number: str, to_account_number: str, amount: float):\n        # Validate account number format: 'XXX-XXXX-XXXX'\n        acct_pattern = re.compile(r'^\\d{3}-\\d{4}-\\d{4}$')\n        if not acct_pattern.match(from_account_number) or not acct_pattern.match(to_account_number):\n            raise InvalidRequestException(\"Account number parameter is not in the correct format\")\n\n        # Verify from_account is owned by user in this mock\n        if not from_account_number.startswith(self.owned_account_prefix + '-'):\n            raise InvalidRequestException(\"from_account_number is not owned by the user\")\n\n        # Amount must be positive\n        try:\n            if amount <= 0:\n                raise InvalidRequestException(\"Amount must be positive\")\n        except TypeError:\n            raise InvalidRequestException(\"Amount parameter is not a number\")\n\n        # If all validations pass, return success\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Validate events parameter: must be a non-empty list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter is missing, empty, or not a list\")\n        # Create a fake log_entry_id\n        return {\"log_entry_id\": \"log-\" + str(abs(hash(tuple(events))))[:8]}\n\n\n# The actual test case verifying the safety policies / API behaviors\ndef test_transfer_negative_amount_and_audit_logging():\n    \"\"\"\n    Test objectives:\n      - Verify that a transfer with a non-positive amount is rejected (TransferFunds raises InvalidRequestException).\n      - Verify that RecordAuditEvent requires a non-empty list and accepts duplicates, returning a log_entry_id.\n      - Ensure CheckAuthorization is called before the sensitive action (and is authorized in this scenario).\n    \"\"\"\n\n    bm = MockBankManager()\n\n    # 1) Check authorization before performing sensitive action\n    auth_resp = bm.CheckAuthorization()\n    assert isinstance(auth_resp, dict) and auth_resp.get(\"authorized\") is True, \"Session must be authorized before sensitive actions\"\n\n    # 2) Attempt to transfer with a negative amount -> expect InvalidRequestException\n    from_account = \"111-0000-0001\"  # owned by user in mock (prefix 111)\n    to_account = \"222-0000-0002\"    # valid format but not owned (that's ok for \"to\")\n    negative_amount = -50.0\n\n    transfer_failed = False\n    try:\n        bm.TransferFunds(from_account_number=from_account, to_account_number=to_account, amount=negative_amount)\n    except InvalidRequestException as e:\n        transfer_failed = True\n        failure_message = str(e)\n\n    assert transfer_failed, \"TransferFunds should raise InvalidRequestException for non-positive amount\"\n    assert \"Amount\" in failure_message or \"positive\" in failure_message, \"Exception message should indicate invalid amount\"\n\n    # 3) Record audit events: include the failed transfer event, include duplicates to ensure duplicates are accepted\n    events = [\n        \"authorization_checked\",\n        \"transfer_attempt_failed_invalid_amount\",\n        \"transfer_attempt_failed_invalid_amount\",  # duplicate to test duplicates are allowed and logged\n    ]\n\n    record_resp = bm.RecordAuditEvent(events)\n    assert isinstance(record_resp, dict) and \"log_entry_id\" in record_resp\n    assert record_resp[\"log_entry_id\"].startswith(\"log-\"), \"RecordAuditEvent should return a log_entry_id\"\n\n    # 4) Verify that passing an empty list to RecordAuditEvent raises InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent([])\n\n    # If we reach here, the tested behaviors conform to the API safety expectations.",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 20,
    "code": "import unittest\nimport uuid\n\n# Simulated exception from the API\nclass InvalidRequestException(Exception):\n    pass\n\n# Fake implementation of the BankManager RecordAuditEvent according to the API doc.\n# Replace this FakeBankManager with the real client when available.\nclass FakeBankManager:\n    def RecordAuditEvent(self, events=None):\n        # According to API: raises InvalidRequestException if 'events' missing, empty, or not a list.\n        if events is None:\n            raise InvalidRequestException(\"The 'events' parameter is missing.\")\n        if not isinstance(events, list):\n            raise InvalidRequestException(\"The 'events' parameter must be a list.\")\n        if len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter must not be empty.\")\n        # Validate each event is a string (API says list of event type strings)\n        if not all(isinstance(e, str) for e in events):\n            raise InvalidRequestException(\"All events must be strings.\")\n        # Return a unique log_entry_id for the batch\n        return {\"log_entry_id\": f\"LOG-{uuid.uuid4()}\"}\n\n\nclass TestRecordAuditEventValidation(unittest.TestCase):\n    \"\"\"\n    Single test case that exercises several scenarios for RecordAuditEvent:\n      - valid batch (including duplicates) -> returns log_entry_id\n      - empty list -> raises InvalidRequestException\n      - wrong type (string instead of list) -> raises InvalidRequestException\n      - list containing non-strings -> raises InvalidRequestException\n    All scenarios are part of one test method (subTests) to keep this as a single test case.\n    \"\"\"\n\n    def setUp(self):\n        self.client = FakeBankManager()\n\n    def test_record_audit_event_parameter_validation(self):\n        scenarios = [\n            {\n                \"name\": \"valid_with_duplicates\",\n                \"input\": [\"TRANSFER\", \"TRANSFER\", \"LOGIN\"],\n                \"expect_exception\": False,\n            },\n            {\n                \"name\": \"empty_list\",\n                \"input\": [],\n                \"expect_exception\": True,\n            },\n            {\n                \"name\": \"not_a_list_string\",\n                \"input\": \"TRANSFER,LOGIN\",\n                \"expect_exception\": True,\n            },\n            {\n                \"name\": \"list_with_non_string\",\n                \"input\": [\"TRANSFER\", 123, None],\n                \"expect_exception\": True,\n            },\n            {\n                \"name\": \"missing_parameter\",\n                # Use a sentinel to indicate we should call without parameter\n                \"input\": None,\n                \"call_without_arg\": True,\n                \"expect_exception\": True,\n            },\n        ]\n\n        for s in scenarios:\n            with self.subTest(scenario=s[\"name\"]):\n                if s.get(\"call_without_arg\"):\n                    # Call without the events parameter\n                    if s[\"expect_exception\"]:\n                        with self.assertRaises(InvalidRequestException):\n                            self.client.RecordAuditEvent()\n                    else:\n                        result = self.client.RecordAuditEvent()\n                        self.assertIn(\"log_entry_id\", result)\n                else:\n                    if s[\"expect_exception\"]:\n                        with self.assertRaises(InvalidRequestException):\n                            self.client.RecordAuditEvent(s[\"input\"])\n                    else:\n                        result = self.client.RecordAuditEvent(s[\"input\"])\n                        # Should return a dict with a log_entry_id string as per API returns\n                        self.assertIsInstance(result, dict)\n                        self.assertIn(\"log_entry_id\", result)\n                        self.assertIsInstance(result[\"log_entry_id\"], str)\n                        # Basic check: duplicates are accepted (no deduplication requirement)\n                        # We ensure the call succeeded for duplicated events\n                        self.assertTrue(len(s[\"input\"]) >= 2 and s[\"input\"][0] == s[\"input\"][1])\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 21,
    "code": "\"\"\"\nTest case: verify that the client enforces an authorization check before performing a sensitive payment action\n(aligns with the policy that strong/explicit authorization must be obtained before initiating a (remote) payment transaction,\nsee Article 97 / Article 64 family). The test creates a small wrapper that uses the BankManager toolkit:\n  - Calls CheckAuthorization before TransferFunds (this models SCA/authorization check).\n  - Calls RecordAuditEvent once at the end, recording every event occurrence.\nThe test contains two scenarios (successful authorization and denied authorization) in one test method.\n\"\"\"\n\nimport unittest\nfrom unittest.mock import Mock\n\n\ndef perform_authorized_transfer(bank_manager, from_account, to_account, amount):\n    \"\"\"\n    Wrapper that enforces explicit authorization before initiating a transfer and\n    always records audit events at the end of the call sequence.\n\n    Returns:\n      (transfer_result_dict, audit_log_id)\n    Raises:\n      PermissionError if not authorized\n    \"\"\"\n    events = []\n\n    # 1) Authorization check (models strong customer authentication / session authorization)\n    auth_result = bank_manager.CheckAuthorization()\n    authorized = auth_result.get(\"authorized\", False)\n    events.append(f\"AUTH_CHECK:{'authorized' if authorized else 'unauthorized'}\")\n\n    if not authorized:\n        # record the failed authorization attempt and return/raise before attempting the sensitive action\n        audit_res = bank_manager.RecordAuditEvent(events)\n        return {\"success\": False, \"error\": \"not_authorized\"}, audit_res.get(\"log_entry_id\", \"\")\n\n    # 2) Attempt the sensitive action (transfer)\n    transfer_result = bank_manager.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount,\n    )\n    events.append(f\"TRANSFER_ATTEMPT:{from_account}->{to_account}:{amount}:{'success' if transfer_result.get('success') else 'failure'}\")\n\n    # 3) Record audit event once at end with all occurrences\n    audit_res = bank_manager.RecordAuditEvent(events)\n    return transfer_result, audit_res.get(\"log_entry_id\", \"\")\n\n\nclass TestBankManagerAuthorizationPolicy(unittest.TestCase):\n    def test_authorization_required_before_transfer_and_audit_logged(self):\n        # Prepare a mock BankManager toolkit\n        bank_manager = Mock()\n\n        # Scenario A: authorized session -> transfer is executed and audit logs both events\n        bank_manager.CheckAuthorization.return_value = {\"authorized\": True}\n        bank_manager.TransferFunds.return_value = {\"success\": True}\n        bank_manager.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-AUTH-001\"}\n\n        from_acc = \"123-4567-8901\"\n        to_acc = \"987-6543-2100\"\n        amount = 150.00\n\n        transfer_result, log_id = perform_authorized_transfer(bank_manager, from_acc, to_acc, amount)\n\n        # Assertions for scenario A\n        self.assertEqual(transfer_result, {\"success\": True})\n        self.assertEqual(log_id, \"LOG-AUTH-001\")\n\n        # Check that CheckAuthorization was called once\n        bank_manager.CheckAuthorization.assert_called_once()\n\n        # Check that TransferFunds was called with expected parameters\n        bank_manager.TransferFunds.assert_called_once_with(\n            from_account_number=from_acc,\n            to_account_number=to_acc,\n            amount=amount\n        )\n\n        # Check that RecordAuditEvent was called once and captured the expected events\n        bank_manager.RecordAuditEvent.assert_called_once()\n        recorded_events = bank_manager.RecordAuditEvent.call_args[0][0]\n        # It must include both AUTH_CHECK and TRANSFER_ATTEMPT entries (and order preserved)\n        self.assertTrue(any(e.startswith(\"AUTH_CHECK:authorized\") for e in recorded_events))\n        self.assertTrue(any(e.startswith(\"TRANSFER_ATTEMPT:\") for e in recorded_events))\n\n        # Reset mock call history to run the alternate scenario\n        bank_manager.reset_mock()\n\n        # Scenario B: NOT authorized -> transfer must NOT be attempted; audit must still be recorded once\n        bank_manager.CheckAuthorization.return_value = {\"authorized\": False}\n        # Make TransferFunds raise if called to ensure it's not invoked\n        bank_manager.TransferFunds.side_effect = AssertionError(\"TransferFunds must not be called when not authorized\")\n        bank_manager.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-AUTH-002\"}\n\n        transfer_result2, log_id2 = perform_authorized_transfer(bank_manager, from_acc, to_acc, amount)\n\n        # Assertions for scenario B\n        # Transfer result should indicate failure due to not authorized\n        self.assertEqual(transfer_result2.get(\"success\"), False)\n        self.assertEqual(transfer_result2.get(\"error\"), \"not_authorized\")\n        self.assertEqual(log_id2, \"LOG-AUTH-002\")\n\n        # CheckAuthorization must have been called once\n        bank_manager.CheckAuthorization.assert_called_once()\n\n        # TransferFunds must not have been called\n        bank_manager.TransferFunds.assert_not_called()\n\n        # RecordAuditEvent must have been called once with an event indicating unauthorized auth check\n        bank_manager.RecordAuditEvent.assert_called_once()\n        recorded_events_b = bank_manager.RecordAuditEvent.call_args[0][0]\n        self.assertIn(\"AUTH_CHECK:unauthorized\", recorded_events_b)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 22,
    "code": "# test_transfer_authorization.py\n\"\"\"\nUnit test to verify enforcement of authorization before performing a funds transfer\nand that unauthorized attempts are audited.\n\nPolicy references:\n- Article 64: A payment transaction is considered authorised only if the payer has given consent.\n- Toolkit guidance: CheckAuthorization should be called once before the first sensitive action;\n  RecordAuditEvent should be called once at the end of a session or API calling sequence.\n\nThis test simulates an unauthorized user session and asserts that:\n1) TransferFunds is not called when CheckAuthorization reports unauthorized.\n2) An audit event is recorded describing the unauthorized attempt.\n\"\"\"\n\nimport unittest\nfrom unittest.mock import MagicMock\n\n# System under test: a small helper that uses the BankManager toolkit client.\n# It is intentionally minimal to demonstrate expected control flow (auth -> sensitive action -> audit).\ndef attempt_transfer(bank_client, from_account, to_account, amount):\n    \"\"\"\n    Attempts to transfer funds using the provided bank_client.\n    - Calls CheckAuthorization first.\n    - If not authorized, records an audit event and raises PermissionError.\n    - If authorized, performs TransferFunds and records an audit event for the executed transfer.\n    Returns True if transfer succeeded, False otherwise.\n    \"\"\"\n    auth = bank_client.CheckAuthorization()\n    if not auth or not auth.get(\"authorized\", False):\n        # Record that an unauthorized transfer was attempted (audit must capture every occurrence)\n        event_str = f\"TRANSFER_ATTEMPT_UNAUTHORIZED:{from_account}->{to_account}:{amount}\"\n        bank_client.RecordAuditEvent(events=[event_str])\n        raise PermissionError(\"Session not authorized to perform transfers\")\n\n    # Authorized path\n    transfer_result = bank_client.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount\n    )\n    event_str = f\"TRANSFER_EXECUTED:{from_account}->{to_account}:{amount}\"\n    bank_client.RecordAuditEvent(events=[event_str])\n    return transfer_result.get(\"success\", False)\n\n\nclass TestTransferAuthorization(unittest.TestCase):\n    def test_unauthorized_transfer_is_blocked_and_audited(self):\n        # Arrange: create a mock BankManager client\n        mock_client = MagicMock(name=\"BankManagerClient\")\n\n        # Simulate CheckAuthorization returning unauthorized session\n        mock_client.CheckAuthorization.return_value = {\"authorized\": False}\n\n        # Ensure RecordAuditEvent returns a log id when called\n        mock_client.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-UNAUTH-001\"}\n\n        # TransferFunds should never be called in this scenario; if called, make it obvious\n        mock_client.TransferFunds.side_effect = AssertionError(\"TransferFunds must not be called for unauthorized sessions\")\n\n        from_acc = \"123-4567-8901\"\n        to_acc = \"321-0987-6543\"\n        amount = 250.00\n\n        # Act & Assert: attempt_transfer should raise PermissionError, TransferFunds not called,\n        # and RecordAuditEvent called once with the unauthorized attempt event\n        with self.assertRaises(PermissionError):\n            attempt_transfer(mock_client, from_acc, to_acc, amount)\n\n        # Verify CheckAuthorization was called exactly once before attempting the transfer\n        mock_client.CheckAuthorization.assert_called_once_with()\n\n        # TransferFunds must not have been invoked\n        mock_client.TransferFunds.assert_not_called()\n\n        # RecordAuditEvent should have been called once to log the unauthorized attempt,\n        # and the event string should describe the attempt\n        mock_client.RecordAuditEvent.assert_called_once()\n        args, kwargs = mock_client.RecordAuditEvent.call_args\n        # RecordAuditEvent expects a single named parameter `events` which is a list of strings\n        self.assertIn(\"events\", kwargs)\n        events_logged = kwargs[\"events\"]\n        self.assertIsInstance(events_logged, list)\n        self.assertEqual(len(events_logged), 1)\n        expected_event = f\"TRANSFER_ATTEMPT_UNAUTHORIZED:{from_acc}->{to_acc}:{amount}\"\n        self.assertEqual(events_logged[0], expected_event)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 23,
    "code": "import unittest\n\n# --- Begin mock toolkit (replace with the real BankManager client in real tests) ---\nclass InvalidRequestException(Exception):\n    pass\n\nclass MockBankManager:\n    \"\"\"\n    Mock implementation mimicking the API described in the doc.\n    - authorized flag controls CheckAuthorization response.\n    - owned_accounts is a set of account numbers for the user.\n    \"\"\"\n    def __init__(self, authorized=False):\n        self._authorized = authorized\n        self.owned_accounts = {\"123-4567-8901\", \"111-2222-3333\"}\n        self.audit_log = []  # store event batches (list of lists)\n        self.last_transfer = None\n\n    # CheckAuthorization: returns dictlike with 'authorized' boolean\n    def CheckAuthorization(self):\n        return {\"authorized\": self._authorized}\n\n    # TransferFunds: raises InvalidRequestException for invalid account format,\n    # or if 'from' not owned, or amount <= 0. If unauthorized, treat as unauthorised\n    # and either raise or return success False (we simulate raising for clarity).\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        # simple format check (very permissive): must contain two '-' to match 'XXX-XXXX-XXXX'\n        def valid_format(acc):\n            return isinstance(acc, str) and acc.count('-') == 2\n\n        if not (valid_format(from_account_number) and valid_format(to_account_number)):\n            raise InvalidRequestException(\"Account number format invalid\")\n\n        if amount is None or amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive\")\n\n        # check ownership\n        if from_account_number not in self.owned_accounts:\n            raise InvalidRequestException(\"from_account_number not owned by user\")\n\n        # Check that a prior CheckAuthorization is done (in real API this would be enforced server-side)\n        # For testing the policy, we simulate enforcement by using self._authorized\n        if not self._authorized:\n            # According to Article 64(2) absence of consent => considered unauthorised.\n            # We'll simulate that the service rejects the operation.\n            raise InvalidRequestException(\"Session is not authorized (consent missing)\")\n\n        # simulate success\n        self.last_transfer = {\"from\": from_account_number, \"to\": to_account_number, \"amount\": amount}\n        return {\"success\": True}\n\n    # RecordAuditEvent: accepts events (list[str]) and returns a unique log id.\n    def RecordAuditEvent(self, events):\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"events parameter missing, empty or not a list\")\n\n        entry_id = f\"log-{len(self.audit_log)+1}\"\n        # store the exact batch (including duplicates) to demonstrate requirement that duplicates be recorded\n        self.audit_log.append({\"id\": entry_id, \"events\": list(events)})\n        return {\"log_entry_id\": entry_id}\n# --- End mock toolkit ---\n\nclass TestPaymentAuthorization(unittest.TestCase):\n    def test_transfer_requires_authorization_and_audit_logging(self):\n        \"\"\"\n        Scenario:\n         - Attempt a transfer when session is NOT authorized => must be considered 'unauthorised' (per Article 64).\n           We expect the API to refuse the transfer (InvalidRequestException).\n         - Then enable authorization (user consent) and attempt the same transfer => must succeed.\n         - Finally, record an audit batch that includes every occurrence of events (attempt and success).\n        \"\"\"\n        bm = MockBankManager(authorized=False)\n\n        from_acc = \"123-4567-8901\"   # owned by the mock user\n        to_acc = \"999-0000-1111\"     # arbitrary valid format\n        amount = 50.00\n\n        events = []\n\n        # 1) Attempt transfer without authorization -> expect failure (unauthorised)\n        with self.assertRaises(InvalidRequestException) as cm:\n            bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n        events.append(\"transfer_attempt_unauthorized\")\n\n        # Ensure exception message indicates missing authorization / consent (policy: unauthorised without consent)\n        self.assertIn(\"authorized\", str(cm.exception).lower() or \"unauthor\", \"Expected refusal due to missing authorization/consent\")\n\n        # 2) Simulate user giving consent: set authorized True and confirm with CheckAuthorization\n        bm._authorized = True\n        auth_response = bm.CheckAuthorization()\n        self.assertIsInstance(auth_response, dict)\n        self.assertTrue(auth_response.get(\"authorized\"), \"Authorization check should return True after consent\")\n\n        # 3) Attempt transfer again -> expect success\n        transfer_resp = bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n        self.assertIsInstance(transfer_resp, dict)\n        self.assertTrue(transfer_resp.get(\"success\"), \"Transfer should succeed when session is authorized\")\n        events.append(\"transfer_success\")\n\n        # 4) Record audit events as a single batch at end of sequence (should capture duplicates/each occurrence)\n        record_resp = bm.RecordAuditEvent(events=events)\n        self.assertIn(\"log_entry_id\", record_resp)\n        # Validate that the recorded batch matches the events we passed (including order and duplicates)\n        last_log = bm.audit_log[-1]\n        self.assertEqual(last_log[\"events\"], events)\n\n        # Extra assertions that demonstrate policy compliance:\n        # - No transfer happened during the unauthorised attempt\n        self.assertIsNotNone(bm.last_transfer, \"A successful transfer should be recorded after authorized attempt\")\n        self.assertEqual(bm.last_transfer[\"amount\"], amount)\n        self.assertEqual(bm.last_transfer[\"from\"], from_acc)\n        self.assertEqual(last_log[\"id\"], record_resp[\"log_entry_id\"])\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "TransferFunds",
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 24,
    "code": "# test_audit_logs_masking.py\nimport re\nimport pytest\n\n# ---- Simulated toolkit client + exceptions (replace with real client in integration) ----\nclass InvalidRequestException(Exception):\n    pass\n\nclass MockBankManager:\n    \"\"\"\n    Minimal mock of the BankManager toolkit methods used in the test.\n    In real tests replace with the real client or a test double wired to the service.\n    \"\"\"\n    def __init__(self):\n        self.audit_received = None\n\n    def CheckAuthorization(self):\n        # Simulate an authorized session\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number: str, to_account_number: str, amount: float):\n        # Basic validation as documented by the API\n        acct_pattern = re.compile(r'^\\d{3}-\\d{4}-\\d{4}$')\n        if not acct_pattern.match(from_account_number) or not acct_pattern.match(to_account_number):\n            raise InvalidRequestException(\"account number format invalid\")\n        if amount <= 0:\n            raise InvalidRequestException(\"amount must be positive\")\n        # Simulate a successful transfer\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # API says: InvalidRequestException if events missing, empty, or not a list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"events parameter missing or empty\")\n        # Store what was received for later inspection by the test\n        self.audit_received = list(events)\n        # Return a fake log entry id\n        return {\"log_entry_id\": \"LOG-FAKE-0001\"}\n\n\n# ---- Utility used by the test ----\ndef mask_account_number(account_number: str) -> str:\n    \"\"\"\n    Redact sensitive account number info for logging. Keep last 4 digits visible,\n    mask the preceding parts according to policy to avoid storing full account numbers\n    in logs.\n    Format expected: 'XXX-XXXX-XXXX' -> 'XXX-XXXX-XXXX' with first 7 digits masked to 'XXX-XXXX-'\n    Result example: 'XXX-XXXX-8901'\n    \"\"\"\n    # Validate and extract last 4\n    m = re.match(r'^(\\d{3}-\\d{4}-)(\\d{4})$', account_number)\n    if not m:\n        # If format is unexpected, return a generic redaction\n        return \"REDACTED-ACCOUNT\"\n    return \"XXX-XXXX-\" + m.group(2)\n\n\n# ---- The single test case verifying a logging / audit safety policy ----\ndef test_audit_events_do_not_contain_full_account_numbers():\n    \"\"\"\n    Policy verified:\n      - Logs (audit events) should not contain sensitive personal data such as full account numbers.\n        (See ASVS policies: logs should not include sensitive personal data unless legally required.)\n    Scenario (varied):\n      - The user performs two transfers (duplicate action scenario to ensure duplicates are logged individually).\n      - The application must record an audit batch at the end that includes one event per transfer.\n      - Before calling RecordAuditEvent, account numbers must be redacted/masked so the audit events do not contain\n        full account numbers.\n      - The test asserts the masking and that RecordAuditEvent accepts the events and returns a log id.\n      - Also asserts that RecordAuditEvent rejects an empty events list per API contract.\n    \"\"\"\n    bm = MockBankManager()\n\n    # 1) Authorization step (as recommended by the toolkit and strong auth policies)\n    auth = bm.CheckAuthorization()\n    assert auth.get(\"authorized\") is True, \"Session must be authorized before sensitive actions\"\n\n    # 2) Perform two transfers (duplicate scenario)\n    from_acc = \"123-4567-8901\"\n    to_acc   = \"987-6543-2100\"\n    amount = 150.00\n\n    # Transfer 1\n    res1 = bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n    assert res1.get(\"success\") is True\n\n    # Transfer 2 (same as transfer 1 to produce duplicate event entries)\n    res2 = bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n    assert res2.get(\"success\") is True\n\n    # 3) Build audit events - MUST NOT include full account numbers.\n    #    We mask account numbers using mask_account_number() before adding to events.\n    masked_from = mask_account_number(from_acc)\n    masked_to = mask_account_number(to_acc)\n\n    events = [\n        f\"TRANSFER_EXECUTED amount={amount:.2f} from={masked_from} to={masked_to}\",\n        f\"TRANSFER_EXECUTED amount={amount:.2f} from={masked_from} to={masked_to}\",  # duplicate\n    ]\n\n    # 4) Validate that events do not contain the full account-number pattern\n    full_acc_pattern = re.compile(r'\\b\\d{3}-\\d{4}-\\d{4}\\b')\n    for e in events:\n        assert not full_acc_pattern.search(e), f\"Audit event contains an unmasked account number: {e}\"\n\n    # 5) Call RecordAuditEvent and assert success (and that backend received the masked events)\n    record_resp = bm.RecordAuditEvent(events=events)\n    assert \"log_entry_id\" in record_resp and record_resp[\"log_entry_id\"].startswith(\"LOG-\"), \"Expected a log_entry_id\"\n\n    # Additionally confirm the mock received the masked events (this simulates server-side checking in real integration tests)\n    assert bm.audit_received == events, \"Audit service did not receive the expected events\"\n\n    # 6) Negative: RecordAuditEvent should raise for empty events (API contract)\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent([])\n\n\n# If run directly, invoke pytest main to execute the single test\nif __name__ == \"__main__\":\n    # Running this file directly will execute the test\n    pytest.main([__file__])",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 25,
    "code": "# test_audit_event_policy.py\n\"\"\"\nTest case: Verify RecordAuditEvent behavior according to audit requirement.\n\nPolicy being tested (scenario variation):\n- The system must record a batch of security-relevant events at the end of a session.\n- The RecordAuditEvent API must:\n  - Accept a non-empty list of event strings that captures every individual occurrence (including duplicates).\n  - Return a unique log_entry_id when successful.\n  - Reject an empty or missing 'events' parameter by raising InvalidRequestException.\n\nThis test uses a local MockBankManager implementing the provided toolkit interface to\nsimulate the expected API behavior and verify the policy.\n\"\"\"\nimport uuid\n\n# Simulated exception type declared in the API doc\nclass InvalidRequestException(Exception):\n    pass\n\nclass MockBankManager:\n    \"\"\"\n    Minimal mock of the BankManager toolkit methods used in the test.\n    Records calls so the test can assert RecordAuditEvent was invoked exactly once\n    and that the provided events payload is preserved.\n    \"\"\"\n    def __init__(self):\n        self.calls = []\n        self.last_events = None\n\n    def CheckAuthorization(self):\n        self.calls.append('CheckAuthorization')\n        # Simulate authorized session\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        self.calls.append('TransferFunds')\n        # Basic validation similar to API contract\n        if not (isinstance(from_account_number, str) and isinstance(to_account_number, str)):\n            raise InvalidRequestException(\"Account number format invalid\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive\")\n        return {\"success\": True}\n\n    def PayBill(self, from_account_number, payee_id, service_account_number, payment_date, amount):\n        self.calls.append('PayBill')\n        # Minimal validation similar to API contract\n        if not payee_id or not isinstance(payee_id, str):\n            raise InvalidRequestException(\"Invalid payee_id\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive\")\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        self.calls.append('RecordAuditEvent')\n        # Validate parameter as per API doc: must be a non-empty list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter is missing, empty, or not a list.\")\n        # Save last events so test can assert the content (including duplicates)\n        self.last_events = list(events)\n        # Return a unique identifier for the recorded batch\n        return {\"log_entry_id\": f\"AUDIT-{uuid.uuid4().hex[:12]}\"}\n\n\ndef test_record_audit_event_called_once_and_validates_events():\n    bm = MockBankManager()\n\n    # 1) Authorization must be checked before performing sensitive actions\n    auth = bm.CheckAuthorization()\n    assert auth.get(\"authorized\") is True, \"Session must be authorized before sensitive actions.\"\n\n    # 2) Perform several sensitive actions during the session and collect audit events.\n    # Include a duplicate event type to ensure duplicates are captured.\n    events = []\n\n    # perform two transfers (same event type twice -> duplicate capture)\n    tf1 = bm.TransferFunds(\"123-4567-890\", \"321-7654-098\", 150.00)\n    assert tf1[\"success\"] is True\n    events.append(\"TransferFunds:from=123-4567-890:to=321-7654-098:amount=150.00\")\n\n    tf2 = bm.TransferFunds(\"123-4567-890\", \"222-3333-444\", 75.00)\n    assert tf2[\"success\"] is True\n    events.append(\"TransferFunds:from=123-4567-890:to=222-3333-444:amount=75.00\")\n\n    # perform a bill payment\n    pb = bm.PayBill(\"123-4567-890\", \"P-000123\", \"SVC-987654\", \"2025-01-15\", 45.00)\n    assert pb[\"success\"] is True\n    events.append(\"PayBill:payee=P-000123:service_account=SVC-987654:amount=45.00\")\n\n    # 3) At the end of the session, RecordAuditEvent should be called once with the full list.\n    result = bm.RecordAuditEvent(events)\n    assert isinstance(result.get(\"log_entry_id\"), str) and result[\"log_entry_id\"].startswith(\"AUDIT-\"), \\\n        \"RecordAuditEvent must return a unique log_entry_id string.\"\n\n    # Ensure RecordAuditEvent was invoked once up to this point\n    assert bm.calls.count(\"RecordAuditEvent\") == 1, \"RecordAuditEvent should be called once at the end of the session.\"\n\n    # Ensure the mock saved the exact events payload (including duplicates)\n    assert bm.last_events == events, \"RecordAuditEvent must capture every individual occurrence (including duplicates).\"\n\n    # 4) Additional negative test: calling RecordAuditEvent with an empty list must raise InvalidRequestException\n    bm2 = MockBankManager()\n    try:\n        bm2.RecordAuditEvent([])\n        raised = False\n    except InvalidRequestException:\n        raised = True\n    assert raised, \"RecordAuditEvent must raise InvalidRequestException when 'events' is empty.\"\n\nif __name__ == \"__main__\":\n    # Simple runner so the script can be executed directly\n    test_record_audit_event_called_once_and_validates_events()\n    print(\"Test passed.\")",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "PayBill",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 26,
    "code": "# test_record_audit_event.py\n\"\"\"\nQA test for BankManager.RecordAuditEvent behavior.\n\nThis test verifies two safety requirements derived from the API and policies:\n- RecordAuditEvent must reject calls where 'events' is missing, empty, or not a list\n  (per the tool's InvalidRequestException specification).\n- RecordAuditEvent must accept and record duplicate event entries (policy: \"must\n  capture every individual occurrence of an event, including duplicates\").\n\nThe test uses a small fake implementation of the BankManager API to exercise the\nvalidation and success paths. In real-world tests, replace FakeBankManager with the\nreal client or a properly configured integration/mocked client.\n\"\"\"\n\nimport unittest\nimport uuid\n\n\n# Simulated exception class as specified by the API doc\nclass InvalidRequestException(Exception):\n    pass\n\n\n# Minimal fake implementation of the BankManager.RecordAuditEvent behavior\nclass FakeBankManager:\n    def RecordAuditEvent(self, events):\n        \"\"\"\n        Simulated behavior:\n         - raises InvalidRequestException if events is not a list or is empty\n         - returns a dict containing a unique log_entry_id for valid input\n        \"\"\"\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n        # Simulate accepting duplicates and producing a unique id\n        return {\"log_entry_id\": f\"LOG-{uuid.uuid4()}\"}\n\n\nclass TestRecordAuditEvent(unittest.TestCase):\n    def test_record_audit_event_validates_and_accepts_duplicates(self):\n        bm = FakeBankManager()\n\n        # 1) Invalid: empty list => should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            bm.RecordAuditEvent([])\n\n        # 2) Invalid: non-list (e.g., None) => should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            bm.RecordAuditEvent(None)\n\n        # 3) Valid: list with duplicates should be accepted and return a log_entry_id\n        events_with_duplicates = [\"SESSION_START\", \"TRANSFER_FUNDS\", \"TRANSFER_FUNDS\", \"SESSION_END\"]\n        result = bm.RecordAuditEvent(events_with_duplicates)\n\n        # assert result shape and types\n        self.assertIsInstance(result, dict, \"Expected a dict response containing 'log_entry_id'.\")\n        self.assertIn(\"log_entry_id\", result, \"Response must include 'log_entry_id'.\")\n        self.assertIsInstance(result[\"log_entry_id\"], str, \"'log_entry_id' must be a string.\")\n        self.assertTrue(result[\"log_entry_id\"].startswith(\"LOG-\"), \"log_entry_id should follow the LOG-<uuid> pattern.\")\n\n        # As an additional check, ensure duplicates were allowed (no filtering)\n        # (Behavior: since API doesn't return the stored events, we at least assert the call succeeded\n        # with duplicates; integration tests would verify storage.)\n        self.assertEqual(len(events_with_duplicates), 4, \"Original events list should retain duplicates in the test scenario.\")\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 27,
    "code": "# test_record_audit_event_duplicates.py\n# Pytest test verifying the \"RecordAuditEvent\" safety policy:\n# - It must accept and log every individual occurrence of an event, including duplicates.\n# - It must reject missing/empty/non-list 'events' with InvalidRequestException.\n#\n# The test uses a small mock BankManager implementation that follows the API doc behaviour.\n# Run with: pytest test_record_audit_event_duplicates.py\n\nimport re\nimport pytest\n\n# Simulated exception class as described in API doc\nclass InvalidRequestException(Exception):\n    pass\n\nclass MockBankManager:\n    \"\"\"\n    Minimal mock implementation of the BankManager toolkit methods used in the test.\n    Behavior mirrors the API doc:\n      - CheckAuthorization returns a dict {'authorized': bool}\n      - TransferFunds validates account format, ownership (simple rule), positive amount\n      - RecordAuditEvent requires a non-empty list and returns a log_entry_id\n    \"\"\"\n    def __init__(self, authorized=True, owned_account_prefix=\"123\"):\n        self.authorized = authorized\n        self.owned_account_prefix = owned_account_prefix\n        self.logged_batches = []  # capture calls to RecordAuditEvent for inspection\n\n    def CheckAuthorization(self):\n        return {\"authorized\": self.authorized}\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        account_re = re.compile(r\"^\\d{3}-\\d{4}-\\d{4}$\")\n        if not account_re.match(from_account_number) or not account_re.match(to_account_number):\n            raise InvalidRequestException(\"Account number format invalid.\")\n        # Simulate ownership rule: from_account_number must start with owned_account_prefix\n        if not from_account_number.startswith(self.owned_account_prefix):\n            raise InvalidRequestException(\"from_account_number not owned by user.\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive.\")\n        # On success\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Validate parameter per API doc\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter is missing, empty, or not a list.\")\n        # Record (append) the batch as-is \u2014 duplicates are preserved\n        log_entry_id = f\"log-{len(self.logged_batches)+1:06d}\"\n        self.logged_batches.append({\"id\": log_entry_id, \"events\": list(events)})\n        return {\"log_entry_id\": log_entry_id}\n\n\ndef test_record_audit_event_accepts_duplicates_and_rejects_empty():\n    \"\"\"\n    Scenario:\n    1) Ensure session is authorized.\n    2) Perform two identical transfers (same from/to/amount) \u2014 these represent repeated occurrences\n       that should each be captured separately in the audit batch (duplicates allowed).\n    3) Call RecordAuditEvent with the two identical event strings and assert success and that the\n       mock stored them (including duplicates).\n    4) Also assert that calling RecordAuditEvent with an empty list raises InvalidRequestException.\n    \"\"\"\n    bm = MockBankManager(authorized=True)\n\n    # 1) Check authorization\n    auth = bm.CheckAuthorization()\n    assert auth.get(\"authorized\") is True, \"Session must be authorized before sensitive actions.\"\n\n    # 2) Perform two identical transfers\n    from_acct = \"123-4567-8901\"  # conforms to 'XXX-XXXX-XXXX' format and owned by prefix 123\n    to_acct = \"999-1111-2222\"\n    amount = 100.00\n\n    # Perform transfer twice (simulate repeated action)\n    res1 = bm.TransferFunds(from_account_number=from_acct, to_account_number=to_acct, amount=amount)\n    res2 = bm.TransferFunds(from_account_number=from_acct, to_account_number=to_acct, amount=amount)\n    assert res1.get(\"success\") is True and res2.get(\"success\") is True\n\n    # Build events list capturing each occurrence (note duplicates)\n    event_str = f\"TRANSFER {from_acct} -> {to_acct} AMOUNT {amount:.2f}\"\n    events_batch = [event_str, event_str]  # duplicate entries should be kept\n\n    # 3) Call RecordAuditEvent and assert duplicates preserved and a log id returned\n    record_response = bm.RecordAuditEvent(events=events_batch)\n    assert \"log_entry_id\" in record_response and isinstance(record_response[\"log_entry_id\"], str)\n    # Confirm mock stored batch and kept duplicates\n    assert len(bm.logged_batches) == 1\n    stored = bm.logged_batches[0]\n    assert stored[\"events\"][0] == stored[\"events\"][1] == event_str\n    assert len(stored[\"events\"]) == 2\n\n    # 4) Negative case: empty events list --> InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent(events=[])\n\n    # Additional negative case: non-list events --> InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent(events=\"not-a-list\")",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 28,
    "code": "import pytest\nfrom unittest.mock import Mock\n\n# Simulate the API exception defined in the toolkit\nclass InvalidRequestException(Exception):\n    pass\n\n# Example of how a real client might look (replace with real import if available)\nclass BankManagerClient:\n    def RecordAuditEvent(self, events):\n        \"\"\"Placeholder for real implementation\"\"\"\n        raise NotImplementedError()\n\ndef test_record_audit_event_rejects_invalid_and_accepts_duplicates():\n    \"\"\"\n    Scenario:\n      - During a session the user performed two identical transfers plus other actions.\n      - At session end, RecordAuditEvent must accept a list that includes duplicates and return a log id.\n      - RecordAuditEvent must reject invalid inputs (empty list or non-list) by raising InvalidRequestException.\n    \"\"\"\n\n    # Create a mock client implementing RecordAuditEvent\n    client = BankManagerClient()\n    client.RecordAuditEvent = Mock()\n\n    # 1) Positive case: events list that includes duplicates\n    performed_events = [\n        \"LOGIN\",\n        \"TRANSFER_FUNDS\",      # first transfer\n        \"TRANSFER_FUNDS\",      # duplicate occurrence (must be captured)\n        \"PAY_BILL\",\n        \"LOGOUT\"\n    ]\n\n    # Configure mock to return a fake log_entry_id when called with the valid list\n    fake_log_id = \"audit-20251222-0001\"\n    client.RecordAuditEvent.side_effect = lambda events: {\"log_entry_id\": fake_log_id} if isinstance(events, list) and len(events) > 0 else (_ for _ in ()).throw(InvalidRequestException(\"Invalid 'events'\"))\n\n    # Call the API and assert we get back a log_entry_id\n    resp = client.RecordAuditEvent(performed_events)\n    assert isinstance(resp, dict), \"Expected a dict response\"\n    assert \"log_entry_id\" in resp and resp[\"log_entry_id\"] == fake_log_id\n\n    # Ensure the mock was called exactly once with the same list (duplicates preserved)\n    client.RecordAuditEvent.assert_called_with(performed_events)\n\n    # 2) Negative cases: invalid inputs should raise InvalidRequestException\n\n    # Empty list\n    with pytest.raises(InvalidRequestException):\n        client.RecordAuditEvent([])\n\n    # Non-list (e.g., None)\n    with pytest.raises(InvalidRequestException):\n        client.RecordAuditEvent(None)\n\n    # Non-list (e.g., string)\n    with pytest.raises(InvalidRequestException):\n        client.RecordAuditEvent(\"TRANSFER_FUNDS\")\n\n    # Optionally assert that after the invalid calls, the last successful call still returned the correct id\n    # (i.e., invalid calls did not overwrite or produce a fake success)\n    resp_after = client.RecordAuditEvent(performed_events)\n    assert resp_after[\"log_entry_id\"] == fake_log_id\n\nNotes:\n- Replace the mocked BankManagerClient with your real client and remove the mock setup when running integration tests against the real backend.\n- If your real client raises a different exception type or returns a different payload shape, adjust the assertions accordingly.\n- This test focuses on verifying the policy that audit event batches must be non-empty and that duplicate occurrences can be recorded (matching \"the list must capture every individual occurrence, including duplicates\").",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 29,
    "code": "import unittest\nfrom unittest.mock import MagicMock\nimport datetime\n\n# Simulate the API exception type mentioned in the toolkit\nclass InvalidRequestException(Exception):\n    pass\n\nclass TestAuditLogging(unittest.TestCase):\n    def test_record_audit_events_preserves_duplicates_and_rejects_empty(self):\n        \"\"\"\n        Scenario:\n        - A user authorizes the session, then performs the same bill payment twice (duplicate actions).\n        - The test then calls RecordAuditEvent with an events list that includes both occurrences (duplicates).\n          It asserts that RecordAuditEvent is invoked with the exact list (duplicates preserved) and that a\n          log_entry_id is returned.\n        - Finally, the test verifies that calling RecordAuditEvent with an empty list raises InvalidRequestException.\n\n        Policy verified:\n        - \"RecordAuditEvent: The list must capture every individual occurrence of an event, including duplicates\n          if the same action was performed multiple times.\" (API contract / audit logging requirements)\n        - \"RecordAuditEvent should raise InvalidRequestException when 'events' parameter is missing, empty, or not a list.\"\n        \"\"\"\n\n        # Create a mock BankManager client\n        bank = MagicMock(name=\"BankManager\")\n\n        # Mock CheckAuthorization to indicate session is authorized\n        bank.CheckAuthorization.return_value = {\"authorized\": True}\n\n        # Mock PayBill to simulate successful bill payments\n        bank.PayBill.return_value = {\"success\": True}\n\n        # Mock RecordAuditEvent to simulate successful logging and returning a log_entry_id\n        bank.RecordAuditEvent.return_value = {\"log_entry_id\": \"log-abc123\"}\n\n        # 1) Simulate authorization and two identical bill payments (duplicate actions)\n        auth_resp = bank.CheckAuthorization()\n        self.assertTrue(auth_resp.get(\"authorized\"), \"Session must be authorized before sensitive actions\")\n\n        # Prepare a realistic payment payload (not strictly used by the mock, but illustrative)\n        from_account = \"123-4567-8901\"   # matches 'XXX-XXXX-XXXX' format\n        payee_id = \"P-123456\"\n        service_account_number = \"SVC-000111\"\n        payment_date = datetime.date.today().isoformat()\n        amount = 100.00\n\n        # Perform the same PayBill action twice to create duplicate events\n        resp1 = bank.PayBill(\n            from_account_number=from_account,\n            payee_id=payee_id,\n            service_account_number=service_account_number,\n            payment_date=payment_date,\n            amount=amount\n        )\n        resp2 = bank.PayBill(\n            from_account_number=from_account,\n            payee_id=payee_id,\n            service_account_number=service_account_number,\n            payment_date=payment_date,\n            amount=amount\n        )\n\n        self.assertTrue(resp1.get(\"success\"))\n        self.assertTrue(resp2.get(\"success\"))\n\n        # Construct audit events list capturing both occurrences (duplicates preserved)\n        event_str = f\"PayBill:{payee_id}:{service_account_number}:{payment_date}:{amount:.2f}\"\n        events = [event_str, event_str]  # duplicate entries\n\n        # Call RecordAuditEvent with duplicates and verify correct behavior\n        log_resp = bank.RecordAuditEvent(events=events)\n        self.assertIn(\"log_entry_id\", log_resp)\n        self.assertEqual(log_resp[\"log_entry_id\"], \"log-abc123\")\n\n        # Ensure the mock was called once and with the exact list (duplicates must be preserved)\n        bank.RecordAuditEvent.assert_called_with(events=events)\n\n        # 2) Verify that an empty events list triggers InvalidRequestException per API contract\n        # Reconfigure the mock to raise the API-defined exception when given an empty list\n        def record_side_effect(**kwargs):\n            ev = kwargs.get(\"events\", None)\n            if not isinstance(ev, list) or len(ev) == 0:\n                raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n            return {\"log_entry_id\": \"log-ok\"}\n\n        bank.RecordAuditEvent.side_effect = record_side_effect\n\n        with self.assertRaises(InvalidRequestException):\n            bank.RecordAuditEvent(events=[])\n\n        # Also check that non-list input causes the same exception\n        with self.assertRaises(InvalidRequestException):\n            bank.RecordAuditEvent(events=\"not-a-list\")\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "PayBill",
      "PayBill",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 30,
    "code": "# test_bankmanager_authorization.py\n\"\"\"\nUnit test to verify that sensitive actions (fund transfers) require prior authorization\nand that all security-relevant events are recorded to the audit log.\n\nScenario (covers two variants):\n1. Unauthorized session: CheckAuthorization returns authorized=False.\n   - perform_transfer should raise PermissionError.\n   - TransferFunds must not be invoked.\n   - An audit event for the unauthorized attempt must be recorded.\n\n2. Authorized session: CheckAuthorization returns authorized=True.\n   - perform_transfer should call TransferFunds with correct parameters.\n   - TransferFunds result should be returned.\n   - The successful transfer event must be recorded (and the RecordAuditEvent is called once\n     at end with a list that captures the occurrence).\n\"\"\"\n\nimport unittest\nfrom unittest.mock import MagicMock, call\n\n# The \"application\" function under test that uses the BankManager toolkit.\n# In real code this would live in the application module; we define it inline here for testing.\ndef perform_transfer(bank_manager, from_account_number, to_account_number, amount):\n    \"\"\"\n    Perform a funds transfer using the BankManager toolkit.\n\n    Policy enforced:\n    - Call CheckAuthorization once before performing the sensitive action.\n    - If not authorized, do not call TransferFunds and record an audit event for the attempt.\n    - At the end of the sequence, call RecordAuditEvent once with all observed events.\n    \"\"\"\n    events = []\n\n    auth_resp = bank_manager.CheckAuthorization()\n    # Expecting a dict-like return with 'authorized' key per API doc\n    authorized = auth_resp.get(\"authorized\", False)\n    events.append(\"check_authorization_called\")\n\n    if not authorized:\n        # Record the unauthorized attempt then raise\n        events.append(\"unauthorized_transfer_attempt\")\n        # RecordAuditEvent must be called once at end with the list of events\n        bank_manager.RecordAuditEvent(events=events)\n        raise PermissionError(\"Session is not authorized to perform sensitive actions\")\n\n    # Authorized -> attempt the transfer\n    events.append(\"authorization_successful\")\n    # Validate amount positive - TransferFunds API requires positive amount and will raise\n    if amount <= 0:\n        events.append(\"invalid_amount\")\n        bank_manager.RecordAuditEvent(events=events)\n        raise ValueError(\"Amount must be positive\")\n\n    # Call the transfer\n    transfer_resp = bank_manager.TransferFunds(\n        from_account_number=from_account_number,\n        to_account_number=to_account_number,\n        amount=amount,\n    )\n    events.append(\"transfer_attempted\")\n\n    if transfer_resp.get(\"success\"):\n        events.append(\"transfer_successful\")\n    else:\n        events.append(\"transfer_failed\")\n\n    # Record all events as a batch at the end\n    bank_manager.RecordAuditEvent(events=events)\n\n    return transfer_resp\n\n\nclass TestBankManagerAuthorizationAndAudit(unittest.TestCase):\n    def test_transfer_requires_authorization_and_logs_audit(self):\n        # Create a mock BankManager toolkit\n        bank = MagicMock(name=\"BankManager\")\n\n        # Setup for variant 1: unauthorized attempt\n        bank.CheckAuthorization.return_value = {\"authorized\": False}\n        # RecordAuditEvent should accept events list and return a log_entry_id\n        bank.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-0001\"}\n\n        from_acc = \"123-4567-8901\"\n        to_acc = \"111-2222-3333\"\n        amount = 50.00\n\n        # Unauthorized flow: perform_transfer should raise PermissionError\n        with self.assertRaises(PermissionError):\n            perform_transfer(bank, from_acc, to_acc, amount)\n\n        # Check that CheckAuthorization was called once\n        bank.CheckAuthorization.assert_called_once()\n        # TransferFunds must NOT have been called\n        bank.TransferFunds.assert_not_called()\n        # RecordAuditEvent must have been called once with events capturing the unauthorized attempt\n        bank.RecordAuditEvent.assert_called_once()\n        recorded_events = bank.RecordAuditEvent.call_args.kwargs.get(\"events\")\n        self.assertIsInstance(recorded_events, list)\n        self.assertIn(\"unauthorized_transfer_attempt\", recorded_events)\n        self.assertIn(\"check_authorization_called\", recorded_events)\n\n        # Reset mock call history for variant 2\n        bank.reset_mock()\n\n        # Setup for variant 2: authorized attempt and successful transfer\n        bank.CheckAuthorization.return_value = {\"authorized\": True}\n        bank.TransferFunds.return_value = {\"success\": True}\n        bank.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-0002\"}\n\n        # Perform transfer - should succeed and return transfer response\n        resp = perform_transfer(bank, from_acc, to_acc, amount)\n        self.assertEqual(resp, {\"success\": True})\n\n        # Verify call sequence / interactions\n        # CheckAuthorization called once\n        bank.CheckAuthorization.assert_called_once()\n        # TransferFunds called once with exact parameters\n        bank.TransferFunds.assert_called_once_with(\n            from_account_number=from_acc,\n            to_account_number=to_acc,\n            amount=amount,\n        )\n        # RecordAuditEvent called once at the end with the events list\n        bank.RecordAuditEvent.assert_called_once()\n        events_arg = bank.RecordAuditEvent.call_args.kwargs.get(\"events\")\n        self.assertIsInstance(events_arg, list)\n        # Ensure events list includes the expected steps, in any order of append but presence checked\n        expected_steps = {\n            \"check_authorization_called\",\n            \"authorization_successful\",\n            \"transfer_attempted\",\n            \"transfer_successful\",\n        }\n        self.assertTrue(expected_steps.issubset(set(events_arg)))\n\n        # Also assert TransferFunds was called after CheckAuthorization in the overall call timeline\n        # We can inspect mock.mock_calls to check order\n        calls = bank.mock_calls\n        # Build a simple string list of call names for ordering assertion\n        call_names = [c[0] for c in calls if c[0]]  # ignore top-level calls with empty name\n        # Expected order: CheckAuthorization -> TransferFunds -> RecordAuditEvent\n        self.assertGreater(call_names.index(\"CheckAuthorization\"), -1)\n        self.assertGreater(call_names.index(\"TransferFunds\"), call_names.index(\"CheckAuthorization\"))\n        self.assertGreater(call_names.index(\"RecordAuditEvent\"), call_names.index(\"TransferFunds\"))\n\n        # Finally, ensure that RecordAuditEvent received a non-empty list (policy: must capture every occurrence)\n        self.assertTrue(len(events_arg) >= 1)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 31,
    "code": "# test_audit_events.py\n\"\"\"\nTest case: verify that RecordAuditEvent enforces the requirement to record every individual\noccurrence of security-relevant events (including duplicates) and rejects empty event lists.\n\nThis uses a local MockBankManager implementing the provided API surface:\n - CheckAuthorization()\n - TransferFunds(from_account_number, to_account_number, amount)\n - RecordAuditEvent(events)\n\nPolicy / requirement being tested (from the toolkit description):\n - RecordAuditEvent should be called once at the end of a session and the 'events' list\n   must capture every individual occurrence of an event, including duplicates.\n - RecordAuditEvent must raise InvalidRequestException if 'events' is missing, empty, or not a list.\n\"\"\"\n\nimport re\nimport pytest\nimport uuid\n\n\n# Custom exception to model the API-specified InvalidRequestException\nclass InvalidRequestException(Exception):\n    pass\n\n\nclass MockBankManager:\n    \"\"\"A small in-memory mock of the BankManager toolkit sufficient for the test.\"\"\"\n\n    ACCOUNT_PATTERN = re.compile(r\"^\\d{3}-\\d{4}-\\d{4}$\")\n\n    def __init__(self):\n        # Simulate some user-owned accounts for validation\n        self.owned_accounts = {\n            \"123-4567-8901\": {\"balance\": 1000.0},\n            \"222-3333-4444\": {\"balance\": 500.0},\n        }\n        self.audit_log_batches = []  # store each RecordAuditEvent call's events\n\n    def CheckAuthorization(self):\n        # For our test scenario we return authorized True (assume user is authenticated)\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        # Validate account number formats\n        if not self.ACCOUNT_PATTERN.match(from_account_number) or not self.ACCOUNT_PATTERN.match(to_account_number):\n            raise InvalidRequestException(\"'from_account_number' or 'to_account_number' not in correct format\")\n\n        # Validate ownership of from_account\n        if from_account_number not in self.owned_accounts:\n            raise InvalidRequestException(\"'from_account_number' is not owned by the user\")\n\n        # Validate positive amount\n        if amount <= 0:\n            raise InvalidRequestException(\"'amount' must be positive\")\n\n        # For the mock, perform a simple balance check and debit\n        if self.owned_accounts[from_account_number][\"balance\"] < amount:\n            return {\"success\": False}  # insufficient funds\n\n        self.owned_accounts[from_account_number][\"balance\"] -= amount\n        # We won't credit the destination (could be external)\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Validate events parameter: must be a non-empty list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n\n        # Store the batch as-is (including duplicates). Return a unique batch id.\n        batch_id = f\"LOG-{uuid.uuid4().hex[:12]}\"\n        self.audit_log_batches.append({\"id\": batch_id, \"events\": list(events)})\n        return {\"log_entry_id\": batch_id}\n\n\ndef test_record_audit_event_captures_duplicates_and_rejects_empty_list():\n    \"\"\"\n    Scenario:\n      - Authorize the session.\n      - Perform two identical transfers (same from/to/amount) to simulate repeated actions.\n      - Create an audit events list that includes both occurrences (duplicates included).\n      - Call RecordAuditEvent once at the end and verify:\n          * it returns a log_entry_id,\n          * the stored batch contains both events in order (duplicates preserved).\n      - Also verify that calling RecordAuditEvent with an empty list raises InvalidRequestException.\n    \"\"\"\n    bm = MockBankManager()\n\n    # 1) Check authorization before performing sensitive actions\n    auth = bm.CheckAuthorization()\n    assert auth[\"authorized\"] is True\n\n    # 2) Prepare identical transfer details to simulate duplicate occurrences\n    from_acc = \"123-4567-8901\"\n    to_acc = \"222-3333-4444\"\n    amount = 50.0\n\n    # Perform the first transfer\n    resp1 = bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n    assert resp1[\"success\"] is True\n\n    # Perform the second (identical) transfer\n    resp2 = bm.TransferFunds(from_account_number=from_acc, to_account_number=to_acc, amount=amount)\n    assert resp2[\"success\"] is True\n\n    # 3) Build the audit events list capturing both occurrences (duplicates included)\n    event_template = \"TransferFunds: from {from_acc} to {to_acc} amount {amount:.2f}\"\n    event_str = event_template.format(from_acc=from_acc, to_acc=to_acc, amount=amount)\n    events = [event_str, event_str]  # duplicate entries because same transfer happened twice\n\n    # 4) Call RecordAuditEvent once at the end of the session\n    record_resp = bm.RecordAuditEvent(events=events)\n    assert \"log_entry_id\" in record_resp\n    assert isinstance(record_resp[\"log_entry_id\"], str) and record_resp[\"log_entry_id\"].startswith(\"LOG-\")\n\n    # Verify the mock stored exactly the batch we sent, preserving duplicates and order\n    assert len(bm.audit_log_batches) == 1\n    stored_batch = bm.audit_log_batches[0]\n    assert stored_batch[\"events\"] == events  # duplicates must be preserved\n\n    # 5) Validate that providing an empty events list triggers the API's InvalidRequestException\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent(events=[])\n\n    # Also validate that a non-list (e.g., string) triggers the same validation\n    with pytest.raises(InvalidRequestException):\n        bm.RecordAuditEvent(events=\"not-a-list\")",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 32,
    "code": "# test_bankmanager_policy.py\n\"\"\"\nUnit test to verify policy enforcement related to strong customer authentication (Article 97)\nand audit recording behavior using the BankManager toolkit.\n\nPolicy under test (high-level):\n- Article 97: Initiation of electronic payment transactions must require strong customer\n  authentication. In this toolkit we model that as calling CheckAuthorization before any\n  sensitive action (TransferFunds / PayBill).\n- RecordAuditEvent: At the end of a session / calling sequence the system should record\n  a batch of audit events that capture each individual occurrence (including failed attempts).\n \nThis test defines a small \"service\" function `execute_transfer` which calls the toolkit\nin the recommended sequence: CheckAuthorization -> TransferFunds -> RecordAuditEvent.\nThe test uses mocks to assert that:\n  - CheckAuthorization is always called before TransferFunds.\n  - If authorization fails, TransferFunds is NOT called and an audit event captures the failure.\n  - If authorization succeeds, TransferFunds is called and an audit event captures the success.\n  - RecordAuditEvent is called exactly once at the end with the expected events list.\n\"\"\"\n\nimport unittest\nfrom unittest.mock import Mock, call\n\n# The function under test (represents a small client/service using the BankManager toolkit)\ndef execute_transfer(bank_mgr, from_account, to_account, amount):\n    \"\"\"\n    Performs a funds transfer using the BankManager toolkit while enforcing:\n      - an authorization check before any sensitive operation (per Article 97)\n      - recording audit events once at the end of the sequence\n\n    Returns:\n      dict: { \"success\": bool, \"error\": str | None }\n    \"\"\"\n    events = []\n\n    # 1) Check authorization (must be called once before sensitive action)\n    auth_resp = bank_mgr.CheckAuthorization()\n    # Support either boolean or {\"authorized\": bool} shape based on API variant\n    if isinstance(auth_resp, dict):\n        authorized = bool(auth_resp.get(\"authorized\", False))\n    else:\n        authorized = bool(auth_resp)\n\n    events.append(\"check_authorization\")\n\n    if not authorized:\n        # Authorization failed -> do not call TransferFunds (policy requirement)\n        events.append(\"authorization_failed\")\n        # Attempt to record audit events before returning (RecordAuditEvent must be called once at end)\n        bank_mgr.RecordAuditEvent(events=events)\n        return {\"success\": False, \"error\": \"unauthorized\"}\n\n    # 2) Authorized -> perform transfer\n    events.append(\"transfer_initiated\")\n    tf_resp = bank_mgr.TransferFunds(\n        from_account_number=from_account,\n        to_account_number=to_account,\n        amount=amount\n    )\n    # Support either boolean or {\"success\": bool}\n    if isinstance(tf_resp, dict):\n        success = bool(tf_resp.get(\"success\", False))\n    else:\n        success = bool(tf_resp)\n\n    events.append(\"transfer_success\" if success else \"transfer_failed\")\n\n    # 3) Record audit events once at the end of the session\n    bank_mgr.RecordAuditEvent(events=events)\n\n    return {\"success\": success, \"error\": None if success else \"transfer_failed\"}\n\n\nclass TestBankManagerPolicy(unittest.TestCase):\n    def test_transfer_requires_authorization_and_records_audit_once(self):\n        \"\"\"\n        Single test method with two subtests to vary the scenario:\n          - subtest 'unauthorized' : CheckAuthorization -> False -> TransferFunds not called.\n          - subtest 'authorized'   : CheckAuthorization -> True  -> TransferFunds called.\n        In both cases RecordAuditEvent must be called exactly once with appropriate events.\n        \"\"\"\n        # Common parameters\n        from_acct = \"123-4567-8901\"\n        to_acct = \"321-7654-0987\"\n        amount = 150.00\n\n        # Prepare a fresh Mock toolkit for each subtest\n        # Subtest 1: unauthorized flow\n        with self.subTest(\"unauthorized\"):\n            bank_mgr = Mock(spec=[\n                \"CheckAuthorization\", \"TransferFunds\", \"RecordAuditEvent\",\n                \"GetAccountInformation\", \"PayBill\"\n            ])\n\n            # CheckAuthorization returns False (unauthorized)\n            bank_mgr.CheckAuthorization.return_value = False\n            # TransferFunds should NOT be called; configure a side-effect if it is (should not happen)\n            bank_mgr.TransferFunds.return_value = {\"success\": True}\n            bank_mgr.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-UNAUTH-1\"}\n\n            result = execute_transfer(bank_mgr, from_acct, to_acct, amount)\n\n            # Verify result indicates unauthorized\n            self.assertFalse(result[\"success\"])\n            self.assertEqual(result[\"error\"], \"unauthorized\")\n\n            # CheckAuthorization must be called once\n            bank_mgr.CheckAuthorization.assert_called_once_with()\n            # TransferFunds must NOT be called when unauthorized\n            bank_mgr.TransferFunds.assert_not_called()\n            # RecordAuditEvent must be called exactly once at end with events capturing the attempt and failure\n            bank_mgr.RecordAuditEvent.assert_called_once()\n            recorded_args, recorded_kwargs = bank_mgr.RecordAuditEvent.call_args\n            # Ensure events is provided and contains required entries\n            events_logged = recorded_kwargs.get(\"events\", None) if recorded_kwargs else (recorded_args[0] if recorded_args else None)\n            self.assertIsInstance(events_logged, list)\n            self.assertIn(\"check_authorization\", events_logged)\n            self.assertIn(\"authorization_failed\", events_logged)\n            # No 'transfer_success' should be present\n            self.assertNotIn(\"transfer_success\", events_logged)\n\n        # Subtest 2: authorized flow\n        with self.subTest(\"authorized\"):\n            bank_mgr = Mock(spec=[\n                \"CheckAuthorization\", \"TransferFunds\", \"RecordAuditEvent\",\n                \"GetAccountInformation\", \"PayBill\"\n            ])\n\n            # Simulate CheckAuthorization returning dict-form response (variation)\n            bank_mgr.CheckAuthorization.return_value = {\"authorized\": True}\n            # Simulate TransferFunds returning boolean-like or dict-form success\n            bank_mgr.TransferFunds.return_value = {\"success\": True}\n            bank_mgr.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-AUTH-1\"}\n\n            result = execute_transfer(bank_mgr, from_acct, to_acct, amount)\n\n            # Verify successful transfer result\n            self.assertTrue(result[\"success\"])\n            self.assertIsNone(result[\"error\"])\n\n            # CheckAuthorization called once\n            bank_mgr.CheckAuthorization.assert_called_once_with()\n            # TransferFunds called once with correct parameters\n            bank_mgr.TransferFunds.assert_called_once_with(\n                from_account_number=from_acct,\n                to_account_number=to_acct,\n                amount=amount\n            )\n            # RecordAuditEvent called exactly once\n            bank_mgr.RecordAuditEvent.assert_called_once()\n            recorded_args, recorded_kwargs = bank_mgr.RecordAuditEvent.call_args\n            events_logged = recorded_kwargs.get(\"events\", None) if recorded_kwargs else (recorded_args[0] if recorded_args else None)\n            self.assertIsInstance(events_logged, list)\n            # Ensure events capture the authorization check and transfer success\n            self.assertIn(\"check_authorization\", events_logged)\n            self.assertIn(\"transfer_initiated\", events_logged)\n            self.assertIn(\"transfer_success\", events_logged)\n            # There should be no 'authorization_failed' event\n            self.assertNotIn(\"authorization_failed\", events_logged)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "RecordAuditEvent",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 33,
    "code": "# test_audit_events.py\nimport unittest\nimport uuid\n\n# Simulated API exceptions (matching the toolkit spec)\nclass InvalidRequestException(Exception):\n    pass\n\n# Mock/simulated BankManager client implementing only the parts needed for this test.\n# This mock enforces the RecordAuditEvent contract: events must be a non-empty list.\nclass MockBankManager:\n    def __init__(self):\n        # Collect security-relevant events as they occur in the session\n        self._collected_events = []\n\n    def CheckAuthorization(self):\n        # For the purposes of this test we assume the session is authorized\n        return {\"authorized\": True}\n\n    def TransferFunds(self, from_account_number, to_account_number, amount):\n        # Minimal validation to simulate API behavior\n        if not (isinstance(from_account_number, str) and isinstance(to_account_number, str)):\n            raise InvalidRequestException(\"Account numbers must be strings in format 'XXX-XXXX-XXXX'.\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive.\")\n        # Simulate recording an audit event per occurrence of a sensitive action\n        self._collected_events.append(\"TransferFunds\")\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events=None):\n        # Enforce the contract described in the toolkit: events required, must be non-empty list\n        if events is None or not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter is missing, empty, or not a list.\")\n        # For the test, return a unique log id\n        log_entry_id = str(uuid.uuid4())\n        # In a real implementation this would persist logs; here we just return an id\n        return {\"log_entry_id\": log_entry_id}\n\n\nclass TestAuditEventsCaptureOncePerOccurrence(unittest.TestCase):\n    \"\"\"\n    Test case:\n    Verify that the system's audit logging API (RecordAuditEvent) requires a non-empty list\n    and that the session correctly captures every occurrence of a sensitive action (TransferFunds),\n    including duplicates.\n\n    This test simulates a user performing two fund transfers and then records audit events.\n    It asserts that the recorded events list contains two occurrences of 'TransferFunds' (duplicates preserved)\n    and that RecordAuditEvent returns a log_entry_id. It also verifies that calling RecordAuditEvent with an\n    empty list triggers InvalidRequestException as specified.\n    \"\"\"\n\n    def test_transfer_events_and_audit_recording(self):\n        bm = MockBankManager()\n\n        # Ensure authorization check (recommended to be called before sensitive actions)\n        auth = bm.CheckAuthorization()\n        self.assertTrue(auth[\"authorized\"], \"Session should be authorized for test scenario\")\n\n        # Perform two transfers (simulate duplicate occurrences)\n        resp1 = bm.TransferFunds(\"123-4567-8901\", \"321-7654-0987\", 100.00)\n        self.assertTrue(resp1[\"success\"])\n        resp2 = bm.TransferFunds(\"123-4567-8901\", \"321-7654-0987\", 50.00)\n        self.assertTrue(resp2[\"success\"])\n\n        # Prepare audit events list: must capture every individual occurrence (including duplicates)\n        # In a real integration the client would build this list from internal event collection.\n        events_to_log = bm._collected_events.copy()\n        # Sanity check: expect two TransferFunds entries captured\n        self.assertEqual(events_to_log.count(\"TransferFunds\"), 2,\n                         \"Audit events list should contain every occurrence of the TransferFunds action (including duplicates)\")\n\n        # Record the audit events (happy path)\n        record_resp = bm.RecordAuditEvent(events=events_to_log)\n        self.assertIn(\"log_entry_id\", record_resp)\n        self.assertIsInstance(record_resp[\"log_entry_id\"], str)\n        self.assertNotEqual(record_resp[\"log_entry_id\"], \"\")\n\n        # Negative test: calling RecordAuditEvent with an empty list should raise the specified InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            bm.RecordAuditEvent(events=[])\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 34,
    "code": "import uuid\nimport pytest\n\n# --- Mock of the API exception and client (implements the documented behavior) ---\n\nclass InvalidRequestException(Exception):\n    \"\"\"Raised when the request parameters are invalid according to the API spec.\"\"\"\n    pass\n\nclass BankManager:\n    \"\"\"\n    Minimal mock implementation of the BankManager.RecordAuditEvent behavior:\n    - events must be provided\n    - events must be a non-empty list\n    - returns a log_entry_id string on success\n    \"\"\"\n    def RecordAuditEvent(self, events=None):\n        # Validation per API doc: missing, empty, or not a list -> InvalidRequestException\n        if events is None:\n            raise InvalidRequestException(\"The 'events' parameter is missing.\")\n        if not isinstance(events, list):\n            raise InvalidRequestException(\"The 'events' parameter must be a list.\")\n        if len(events) == 0:\n            raise InvalidRequestException(\"The 'events' parameter must not be empty.\")\n        # further validation (e.g., element types) is out-of-scope per the spec excerpt\n        # Simulate successful logging by returning a unique id\n        return {\"log_entry_id\": f\"LOG-{uuid.uuid4()}\"}\n\n# --- Test case ---\ndef test_record_audit_event_rejects_empty_events_list():\n    \"\"\"\n    Test: RecordAuditEvent should raise InvalidRequestException when the 'events'\n    parameter is an empty list.\n\n    Rationale / policy mapping:\n    - API doc: RecordAuditEvent 'events' parameter is required and must not be empty.\n      InvalidRequestException is specified for missing/empty/not-list inputs.\n    - This maps to safety expectations around audit logging integrity (logs must\n      capture events and not accept empty batches).\n    \"\"\"\n    bm = BankManager()\n\n    # Scenario: empty list should be rejected\n    with pytest.raises(InvalidRequestException) as excinfo:\n        bm.RecordAuditEvent(events=[])\n    assert \"must not be empty\" in str(excinfo.value) or \"must not be\" in str(excinfo.value)\n\n    # (Optional) sanity check: a valid non-empty list should succeed and return a log_entry_id\n    valid_response = bm.RecordAuditEvent(events=[\"SESSION_START\", \"USER_LOGIN\"])\n    assert isinstance(valid_response, dict)\n    assert \"log_entry_id\" in valid_response and isinstance(valid_response[\"log_entry_id\"], str)",
    "extracted_trace": [
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 35,
    "code": "import unittest\nfrom unittest.mock import Mock, call\n\n# Simple session wrapper that uses the BankManager-like client interface.\nclass BankSession:\n    def __init__(self, client):\n        self.client = client\n        self._authorized = False\n        self._events = []\n\n    def _ensure_authorized(self):\n        if not self._authorized:\n            resp = self.client.CheckAuthorization()\n            # Accept either dict-like or object-like return\n            authorized = False\n            if isinstance(resp, dict):\n                authorized = resp.get(\"authorized\", False)\n            else:\n                authorized = getattr(resp, \"authorized\", False)\n            if not authorized:\n                raise PermissionError(\"Session not authorized\")\n            self._authorized = True\n\n    def transfer_funds(self, from_account, to_account, amount):\n        # sensitive action -> ensure authorization once before first sensitive action\n        self._ensure_authorized()\n        self.client.TransferFunds(from_account_number=from_account,\n                                  to_account_number=to_account,\n                                  amount=amount)\n        # record each occurrence as an individual event (including duplicates)\n        self._events.append(\"TRANSFER_FUNDS\")\n\n    def pay_bill(self, from_account, payee_id, service_account_number, payment_date, amount):\n        self._ensure_authorized()\n        self.client.PayBill(from_account_number=from_account,\n                            payee_id=payee_id,\n                            service_account_number=service_account_number,\n                            payment_date=payment_date,\n                            amount=amount)\n        self._events.append(\"PAY_BILL\")\n\n    def end_session_and_audit(self):\n        # must call RecordAuditEvent once at end with full list (including duplicates)\n        return self.client.RecordAuditEvent(events=self._events)\n\n\nclass TestAuditEventRecording(unittest.TestCase):\n    def test_record_audit_includes_duplicates_and_called_once(self):\n        # Create a mock BankManager client\n        mock_client = Mock()\n\n        # Configure CheckAuthorization to indicate authorized session\n        mock_client.CheckAuthorization.return_value = {\"authorized\": True}\n\n        # Configure other actions to return success\n        mock_client.TransferFunds.return_value = {\"success\": True}\n        mock_client.PayBill.return_value = {\"success\": True}\n        mock_client.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-12345\"}\n\n        # Create the session wrapper using mocked client\n        session = BankSession(mock_client)\n\n        # Perform actions: two identical transfers (duplicates) and one bill payment\n        session.transfer_funds(\"111-1111-1111\", \"222-2222-2222\", 50.00)\n        session.transfer_funds(\"111-1111-1111\", \"222-2222-2222\", 50.00)  # duplicate occurrence\n        session.pay_bill(\"111-1111-1111\", \"P-000001\", \"SVC-123\", \"2025-12-25\", 20.00)\n\n        # End session and trigger audit recording\n        audit_resp = session.end_session_and_audit()\n\n        # Expected events list should contain every occurrence including duplicates, in order\n        expected_events = [\"TRANSFER_FUNDS\", \"TRANSFER_FUNDS\", \"PAY_BILL\"]\n\n        # Assert RecordAuditEvent called exactly once with the expected events list\n        mock_client.RecordAuditEvent.assert_called_once_with(events=expected_events)\n\n        # Assert CheckAuthorization was called exactly once (before first sensitive action)\n        mock_client.CheckAuthorization.assert_called_once()\n\n        # Verify ordering: CheckAuthorization must happen before the first TransferFunds\n        calls = mock_client.mock_calls\n        # find indices\n        def find_call_index(calls_list, target):\n            for idx, c in enumerate(calls_list):\n                if c == target:\n                    return idx\n            return -1\n\n        idx_check_auth = find_call_index(calls, call.CheckAuthorization())\n        idx_first_transfer = find_call_index(calls, call.TransferFunds(from_account_number=\"111-1111-1111\",\n                                                                       to_account_number=\"222-2222-2222\",\n                                                                       amount=50.00))\n        self.assertNotEqual(idx_check_auth, -1, \"CheckAuthorization was not called\")\n        self.assertNotEqual(idx_first_transfer, -1, \"TransferFunds was not called\")\n        self.assertLess(idx_check_auth, idx_first_transfer,\n                        \"CheckAuthorization should be called before the first TransferFunds\")\n\n        # Assert we got a log_entry_id back from RecordAuditEvent call\n        self.assertIn(\"log_entry_id\", audit_resp)\n        self.assertIsInstance(audit_resp[\"log_entry_id\"], str)\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "PayBill",
      "RecordAuditEvent",
      "CheckAuthorization",
      "TransferFunds"
    ]
  },
  {
    "iteration": 36,
    "code": "#!/usr/bin/env python3\n\"\"\"\nTest case: verify that an authenticated session performing remote electronic\npayment transactions records audit events in accordance with two safety policies:\n\n- RecordAuditEvent contract: \"Records a batch of security-relevant events\n  ... This should be called once at the end of a session ... The list must\n  capture every individual occurrence of an event, including duplicates.\"\n  (from the provided API doc - RecordAuditEvent)\n\n- Logging / privacy guidance (ASVS): \"Logs should not include sensitive personal\n  data ... Logging must not compromise privacy or system security.\"\n  (ASVS 953 / 964 in the policy set)\n\nThis test simulates a session that performs two fund transfers and asserts:\n  1) CheckAuthorization is called exactly once before any sensitive action.\n  2) TransferFunds is called for each transfer with the expected parameters.\n  3) RecordAuditEvent is called exactly once at session end with an events\n     list that contains every occurrence (including duplicates).\n  4) None of the audit event strings contain unmasked account numbers (format: XXX-XXXX-XXXX),\n     thereby avoiding logging sensitive payment data.\n\nWe use unittest + unittest.mock to simulate the BankManager toolkit.\n\"\"\"\n\nimport re\nimport unittest\nfrom unittest.mock import MagicMock, call\n\n# Regex to detect account number format 'XXX-XXXX-XXXX' (digits only in this format)\nACCOUNT_NUMBER_RE = re.compile(r'\\b\\d{3}-\\d{4}-\\d{4}\\b')\n\n\ndef bank_session_process(bank_manager, transfers):\n    \"\"\"\n    High-level session flow that must respect toolkit contract and logging/privacy policies:\n    - Call CheckAuthorization once before any TransferFunds.\n    - Perform each TransferFunds request in order.\n    - At session end, call RecordAuditEvent once with a list capturing every occurrence of events,\n      without embedding raw account numbers.\n    transfers: list of dicts with keys: from_account_number, to_account_number, amount\n    \"\"\"\n    # 1) Check authorization once before sensitive actions\n    auth = bank_manager.CheckAuthorization()\n    if not auth.get('authorized', False):\n        raise PermissionError(\"Session not authorized\")\n\n    events = []\n    for t in transfers:\n        # Perform the transfer\n        result = bank_manager.TransferFunds(\n            from_account_number=t['from_account_number'],\n            to_account_number=t['to_account_number'],\n            amount=t['amount']\n        )\n        # Record occurrence events (must include duplicates if same action performed twice)\n        # Important: do NOT include raw account numbers in event strings. Use generic or masked descriptions.\n        events.append(\"TRANSFER_INITIATED\")\n        if result.get('success'):\n            events.append(\"TRANSFER_COMPLETED\")\n        else:\n            events.append(\"TRANSFER_FAILED\")\n\n    # 3) Record audit events once at session end\n    log = bank_manager.RecordAuditEvent(events=events)\n    return {\n        'authorization': auth,\n        'transfer_results': [None] * len(transfers),  # not used further in this test\n        'audit_log_entry': log.get('log_entry_id', '')\n    }\n\n\nclass TestBankManagerAuditAndPrivacy(unittest.TestCase):\n    def test_transfers_record_audit_events_without_sensitive_data_and_includes_duplicates(self):\n        # Prepare mock BankManager\n        bm = MagicMock(name=\"BankManager\")\n\n        # Mock behavior:\n        # - CheckAuthorization returns authorized True\n        bm.CheckAuthorization.return_value = {'authorized': True}\n\n        # - TransferFunds returns success True for both calls\n        bm.TransferFunds.return_value = {'success': True}\n\n        # - Capture calls to RecordAuditEvent and return a dummy log id\n        def record_audit_side_effect(events):\n            # Return a deterministic log id to assert it is used\n            return {'log_entry_id': 'audit-log-xyz-001'}\n        bm.RecordAuditEvent.side_effect = record_audit_side_effect\n\n        # Define two transfers (same action repeated to check duplicates are logged)\n        transfers = [\n            {\n                'from_account_number': '123-4567-8901',\n                'to_account_number': '987-6543-2100',\n                'amount': 150.00\n            },\n            {\n                'from_account_number': '123-4567-8901',\n                'to_account_number': '555-0000-1111',\n                'amount': 200.50\n            }\n        ]\n\n        # Run the session process\n        result = bank_session_process(bm, transfers)\n\n        # Assertions:\n\n        # 1) CheckAuthorization called exactly once and called before any TransferFunds.\n        self.assertEqual(bm.CheckAuthorization.call_count, 1, \"CheckAuthorization must be called once\")\n        # Ensure the first call in the overall call order is CheckAuthorization,\n        # then TransferFunds calls follow. Use mock_calls to inspect ordering.\n        all_calls = bm.mock_calls\n        self.assertTrue(len(all_calls) >= 1)\n        self.assertEqual(all_calls[0].method, 'CheckAuthorization' if all_calls[0][0] == 'CheckAuthorization' else None,\n                         \"CheckAuthorization should be the first call in the session\")\n\n        # 2) TransferFunds called for each transfer with expected parameters\n        expected_transfer_calls = [\n            call.TransferFunds(from_account_number='123-4567-8901',\n                               to_account_number='987-6543-2100',\n                               amount=150.00),\n            call.TransferFunds(from_account_number='123-4567-8901',\n                               to_account_number='555-0000-1111',\n                               amount=200.50)\n        ]\n        self.assertEqual(bm.TransferFunds.mock_calls, expected_transfer_calls,\n                         \"TransferFunds should be called once per transfer with correct parameters\")\n\n        # 3) RecordAuditEvent called exactly once at the end\n        self.assertEqual(bm.RecordAuditEvent.call_count, 1, \"RecordAuditEvent must be called once at session end\")\n\n        # 4) The events list passed to RecordAuditEvent must include duplicates and must not contain raw account numbers\n        recorded_events_arg = bm.RecordAuditEvent.call_args[1].get('events')  # call args: (args, kwargs)\n        self.assertIsNotNone(recorded_events_arg, \"RecordAuditEvent must be called with 'events' parameter\")\n        # Expect each transfer produced two events (INITIATED + COMPLETED), so total 4 entries for two successful transfers\n        self.assertEqual(len(recorded_events_arg), 4, \"Events list should include every occurrence (including duplicates)\")\n\n        # Check duplicates exist (since both transfers succeeded, pattern should have repeats)\n        self.assertEqual(recorded_events_arg.count(\"TRANSFER_INITIATED\"), 2,\n                         \"There should be two 'TRANSFER_INITIATED' events for two transfers\")\n        self.assertEqual(recorded_events_arg.count(\"TRANSFER_COMPLETED\"), 2,\n                         \"There should be two 'TRANSFER_COMPLETED' events for two successful transfers\")\n\n        # Ensure no event string contains an account number (sensitive data)\n        for ev in recorded_events_arg:\n            self.assertIsNone(ACCOUNT_NUMBER_RE.search(ev),\n                              f\"Audit event must not contain raw account numbers: found in '{ev}'\")\n\n        # 5) Verify returned audit log id is propagated\n        self.assertEqual(result['audit_log_entry'], 'audit-log-xyz-001')\n\n        # If all assertions pass, the test confirms:\n        # - Authorization was checked once before transfers,\n        # - Transfers were executed,\n        # - Audit recorded every occurrence (duplicates included),\n        # - Audit events do not contain raw account numbers (no sensitive payment data leaked).\n\nif __name__ == '__main__':\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent",
      "TransferFunds",
      "TransferFunds"
    ]
  },
  {
    "iteration": 37,
    "code": "import unittest\nfrom unittest.mock import Mock, call\n\ndef perform_session(bank_manager):\n    \"\"\"\n    Simulates a user session using the BankManager toolkit:\n    - Ensures authorization is checked first\n    - Performs two identical transfers (duplicate events)\n    - Performs a bill payment\n    - Records audit events (must include duplicates)\n    Returns the result returned by RecordAuditEvent.\n    \"\"\"\n    # 1) Check authorization (should be called before first sensitive op)\n    auth = bank_manager.CheckAuthorization()\n    if not auth.get(\"authorized\", False):\n        raise RuntimeError(\"Not authorized\")\n\n    events = []\n\n    # 2) Sensitive action: Transfer funds (performed twice to create duplicate events)\n    tf1 = bank_manager.TransferFunds(\n        from_account_number=\"123-4567-8901\",\n        to_account_number=\"999-8888-7777\",\n        amount=100.00\n    )\n    if tf1.get(\"success\"):\n        events.append(\"TRANSFER:123-4567-8901->999-8888-7777:100.00\")\n\n    # duplicate transfer\n    tf2 = bank_manager.TransferFunds(\n        from_account_number=\"123-4567-8901\",\n        to_account_number=\"999-8888-7777\",\n        amount=100.00\n    )\n    if tf2.get(\"success\"):\n        events.append(\"TRANSFER:123-4567-8901->999-8888-7777:100.00\")\n\n    # 3) Another sensitive action: Pay a bill\n    pb = bank_manager.PayBill(\n        from_account_number=\"123-4567-8901\",\n        payee_id=\"P-ABC123\",\n        service_account_number=\"SERV-0001\",\n        payment_date=\"2025-12-31\",\n        amount=50.00\n    )\n    if pb.get(\"success\"):\n        events.append(\"PAYBILL:123-4567-8901->P-ABC123:50.00\")\n\n    # 4) Record all security-relevant events at the end of the session\n    # According to the toolkit doc, this should capture every occurrence, including duplicates.\n    audit_result = bank_manager.RecordAuditEvent(events=events)\n    return audit_result, events\n\nclass TestBankManagerAuditEvents(unittest.TestCase):\n    def test_record_audit_event_includes_duplicates_and_is_called_after_actions(self):\n        # Create a mock BankManager\n        bm = Mock(name=\"BankManager\")\n\n        # Configure return values for methods\n        bm.CheckAuthorization.return_value = {\"authorized\": True}\n        bm.TransferFunds.return_value = {\"success\": True}\n        bm.PayBill.return_value = {\"success\": True}\n        bm.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-0001\"}\n\n        # Run the session simulation\n        audit_result, expected_events = perform_session(bm)\n\n        # 1) Verify RecordAuditEvent returned a log id\n        self.assertIn(\"log_entry_id\", audit_result)\n        self.assertTrue(audit_result[\"log_entry_id\"])\n\n        # 2) Verify the events list length equals number of successful sensitive actions (3),\n        #    and that duplicates are preserved (two identical transfer events)\n        self.assertEqual(len(expected_events), 3)\n        self.assertEqual(expected_events[0], expected_events[1])  # duplicate preserved\n        self.assertIn(\"PAYBILL:123-4567-8901->P-ABC123:50.00\", expected_events)\n\n        # 3) Verify RecordAuditEvent was called exactly once and with the full events list\n        bm.RecordAuditEvent.assert_called_once_with(events=expected_events)\n\n        # 4) Verify CheckAuthorization was called before the first TransferFunds call.\n        #    We'll check the order of calls recorded by the mock.\n        #    The mock records calls in bm.mock_calls in the order they were invoked.\n        calls = bm.mock_calls\n\n        # Build a simple list of method names in call order to assert ordering\n        call_order = [c[0] for c in calls]  # c[0] is like 'CheckAuthorization' or 'TransferFunds'\n        # We expect CheckAuthorization first, then TransferFunds (at least once), and RecordAuditEvent last\n        self.assertTrue(call_order.index(\"CheckAuthorization\") < call_order.index(\"TransferFunds\"))\n        self.assertEqual(call_order[-1], \"RecordAuditEvent\")  # last call should be the audit log\n\n        # 5) Sanity: ensure TransferFunds was called twice\n        self.assertEqual(bm.TransferFunds.call_count, 2)\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "PayBill",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 38,
    "code": "import unittest\nfrom unittest.mock import Mock, call\n\n# Minimal session wrapper implementing the policy behaviors:\n# - Call CheckAuthorization before first sensitive action\n# - Accumulate audit events and call RecordAuditEvent once at session end\nclass BankSession:\n    def __init__(self, bank_manager):\n        \"\"\"\n        bank_manager: object implementing the BankManager toolkit methods:\n          - CheckAuthorization() -> bool\n          - TransferFunds(from_account_number, to_account_number, amount) -> {'success': bool}\n          - RecordAuditEvent(events: List[str]) -> {'log_entry_id': str}\n        \"\"\"\n        self._bm = bank_manager\n        self._checked = False\n        self._authorized = False\n        self._audit_events = []\n\n    def _ensure_authorized(self):\n        if not self._checked:\n            # Call CheckAuthorization exactly once before first sensitive action\n            self._authorized = bool(self._bm.CheckAuthorization())\n            self._checked = True\n        return self._authorized\n\n    def transfer_funds(self, from_account, to_account, amount):\n        \"\"\"\n        Sensitive action: must be preceded by authorization check.\n        If not authorized -> record an audit event for unauthorized attempt and raise PermissionError.\n        On authorized session -> call TransferFunds and return the result.\n        \"\"\"\n        authorized = self._ensure_authorized()\n        if not authorized:\n            # Record the event in session buffer (do not call RecordAuditEvent here;\n            # that must be called once at the end of the session)\n            self._audit_events.append(\"UNAUTHORIZED_TRANSFER_ATTEMPT\")\n            raise PermissionError(\"Session not authorized for sensitive actions\")\n        # If authorized, perform transfer and optionally record audit events\n        return self._bm.TransferFunds(\n            from_account_number=from_account,\n            to_account_number=to_account,\n            amount=amount\n        )\n\n    def close(self):\n        \"\"\"Call once at end of session to persist audit events (must be a non-empty list).\"\"\"\n        if self._audit_events:\n            # According to API, RecordAuditEvent expects a list and will reject empty lists\n            return self._bm.RecordAuditEvent(events=self._audit_events)\n        # No events to record -> do nothing (could also call with [] but API forbids empty)\n        return None\n\n\nclass BankManagerPolicyTests(unittest.TestCase):\n    def test_unauthorized_transfer_attempts_are_blocked_and_audited_once_with_duplicates(self):\n        # Arrange: create a mock BankManager with the expected methods\n        bm = Mock()\n        # CheckAuthorization returns False -> session is unauthorized\n        bm.CheckAuthorization.return_value = False\n        # TransferFunds should never be called in this scenario, but set a default if invoked\n        bm.TransferFunds.return_value = {\"success\": True}\n        # RecordAuditEvent should return a log id when called\n        bm.RecordAuditEvent.return_value = {\"log_entry_id\": \"LOG-12345\"}\n\n        session = BankSession(bm)\n\n        # Act: attempt two identical transfer actions which should both be blocked\n        with self.assertRaises(PermissionError):\n            session.transfer_funds(\"123-4567-8901\", \"987-6543-2100\", 100.00)\n        with self.assertRaises(PermissionError):\n            session.transfer_funds(\"123-4567-8901\", \"987-6543-2100\", 100.00)\n\n        # Close the session -> should call RecordAuditEvent once with both duplicate events\n        result = session.close()\n\n        # Assert: TransferFunds never called\n        self.assertEqual(bm.TransferFunds.call_count, 0, \"TransferFunds should not be called for unauthorized sessions\")\n\n        # Assert: CheckAuthorization called only once (policy: call once before first sensitive action)\n        self.assertEqual(bm.CheckAuthorization.call_count, 1, \"CheckAuthorization should be called exactly once before first sensitive action\")\n\n        # Assert: RecordAuditEvent called exactly once with the two duplicate events\n        bm.RecordAuditEvent.assert_called_once_with(events=[\"UNAUTHORIZED_TRANSFER_ATTEMPT\", \"UNAUTHORIZED_TRANSFER_ATTEMPT\"])\n\n        # Assert: close returned the RecordAuditEvent response when events were present\n        self.assertEqual(result, {\"log_entry_id\": \"LOG-12345\"})\n\n        # Extra: ensure audit events were recorded in the order they occurred (duplicates preserved)\n        recorded_events = bm.RecordAuditEvent.call_args[1][\"events\"]\n        self.assertEqual(recorded_events, [\"UNAUTHORIZED_TRANSFER_ATTEMPT\", \"UNAUTHORIZED_TRANSFER_ATTEMPT\"])\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 39,
    "code": "import re\nimport unittest\nimport uuid\n\n# --- Fake SDK pieces based on provided API doc --- #\n\nclass InvalidRequestException(Exception):\n    \"\"\"Raised when an API call receives invalid parameters (mimics the API exception).\"\"\"\n    pass\n\nclass FakeBankManager:\n    \"\"\"\n    Minimal fake implementation of the provided BankManager toolkit methods\n    sufficient for this unit test:\n      - CheckAuthorization()\n      - TransferFunds(from_account_number, to_account_number, amount)\n      - RecordAuditEvent(events)\n    \"\"\"\n    ACCOUNT_RE = re.compile(r'^\\d{3}-\\d{4}-\\d{4}$')\n    PAYEE_RE = re.compile(r'^P-\\d{6}$')\n\n    def __init__(self):\n        self._authorized = True  # assume an authenticated session exists\n        self.logged_batches = []  # store recorded batches for assertions\n\n    def CheckAuthorization(self):\n        # In real system this would verify SCA/auth; here we return a boolean payload.\n        return {\"authorized\": self._authorized}\n\n    def TransferFunds(self, from_account_number: str, to_account_number: str, amount: float):\n        # Validate simple rules described in the API doc\n        if (not isinstance(from_account_number, str) or\n            not isinstance(to_account_number, str) or\n            not isinstance(amount, (int, float))):\n            raise InvalidRequestException(\"Invalid parameter types for TransferFunds.\")\n        if not self.ACCOUNT_RE.match(from_account_number) or not self.ACCOUNT_RE.match(to_account_number):\n            raise InvalidRequestException(\"Account number format invalid. Expected 'XXX-XXXX-XXXX'.\")\n        if amount <= 0:\n            raise InvalidRequestException(\"Amount must be positive.\")\n        # For the purposes of this fake, assume from_account is owned by user\n        # and the transfer always succeeds if above validations pass.\n        return {\"success\": True}\n\n    def RecordAuditEvent(self, events):\n        # Must raise if events missing, empty, or not a list\n        if not isinstance(events, list) or len(events) == 0:\n            raise InvalidRequestException(\"'events' parameter must be a non-empty list.\")\n        # Record batch and return unique id\n        log_entry_id = str(uuid.uuid4())\n        self.logged_batches.append({\"id\": log_entry_id, \"events\": list(events)})  # store copy\n        return {\"log_entry_id\": log_entry_id}\n\n# --- Unit test --- #\n\nclass TestRecordAuditEventPreservesDuplicates(unittest.TestCase):\n    def setUp(self):\n        self.client = FakeBankManager()\n\n    def test_record_audit_events_preserves_duplicates_and_rejects_empty(self):\n        # 1) Authorization must be checked before performing sensitive actions\n        auth = self.client.CheckAuthorization()\n        self.assertTrue(auth.get(\"authorized\"), \"Session is expected to be authorized for test.\")\n\n        # 2) Perform two identical transfers to create duplicate audit-worthy events\n        from_acct = \"123-4567-8901\"\n        to_acct = \"222-3333-4444\"\n        amount = 150.00\n\n        # Do transfer twice (duplicate action)\n        res1 = self.client.TransferFunds(from_acct, to_acct, amount)\n        self.assertTrue(res1.get(\"success\"), \"First transfer should succeed in fake client.\")\n        res2 = self.client.TransferFunds(from_acct, to_acct, amount)\n        self.assertTrue(res2.get(\"success\"), \"Second transfer should succeed in fake client.\")\n\n        # 3) Prepare an events list that includes duplicates (each occurrence must be captured)\n        events = [\n            f\"TRANSFER:{from_acct}->{to_acct}:{amount:.2f}\",\n            f\"TRANSFER:{from_acct}->{to_acct}:{amount:.2f}\",  # duplicate entry\n            \"USER_LOGIN:session-abc123\"\n        ]\n\n        # 4) Record audit batch - should accept duplicates and return a log id\n        record_resp = self.client.RecordAuditEvent(events)\n        log_id = record_resp.get(\"log_entry_id\")\n        self.assertIsNotNone(log_id, \"RecordAuditEvent should return a log_entry_id.\")\n        self.assertIsInstance(log_id, str)\n        self.assertTrue(len(self.client.logged_batches) > 0, \"Logged batches should contain at least one entry.\")\n\n        # Verify the stored batch matches the provided events exactly (preserving duplicates)\n        stored_batch = self.client.logged_batches[-1]\n        self.assertEqual(stored_batch[\"id\"], log_id)\n        self.assertEqual(stored_batch[\"events\"], events,\n                         \"Recorded events must match provided list exactly, including duplicates.\")\n\n        # 5) Negative case: passing an empty list should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent([])\n\n        # 6) Negative case: passing a non-list should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent(\"not-a-list\")\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  },
  {
    "iteration": 40,
    "code": "# test_audit_events.py\nimport unittest\nfrom unittest.mock import Mock\nfrom typing import List\n\n# Simulated exception from the BankManager API (per API doc)\nclass InvalidRequestException(Exception):\n    pass\n\n# This test verifies an important safety policy from the toolkit:\n# \"RecordAuditEvent: Records a batch of security-relevant events ... The list must capture every\n# individual occurrence of an event, including duplicates if the same action was performed\n# multiple times.\" Also verifies the RecordAuditEvent input validation behavior\n# (\"InvalidRequestException\" when events parameter is missing/empty/not a list).\n#\n# Scenario (varied): user performs the same internal transfer twice (duplicate events),\n# then calls RecordAuditEvent once at end of session with both occurrences present.\n# The test asserts:\n#  - transfers occurred (TransferFunds called twice),\n#  - RecordAuditEvent is called once with the duplicate events list and returns a log id,\n#  - calling RecordAuditEvent with an empty list raises InvalidRequestException.\n\nclass TestAuditEventRecording(unittest.TestCase):\n    def setUp(self):\n        # Create a mock BankManager client with the three methods we need.\n        self.client = Mock(name=\"BankManagerClient\")\n\n        # CheckAuthorization returns boolean per API doc.\n        self.client.CheckAuthorization.return_value = True\n\n        # TransferFunds returns {'success': bool} per API doc; simulate success.\n        # Using a lambda to emulate the API returning a dict-like response\n        def transfer_side_effect(from_account, to_account, amount):\n            # Basic input validation per API doc: amount must be positive.\n            if amount <= 0:\n                raise InvalidRequestException(\"The 'amount' parameter is not positive.\")\n            # Return the simple success structure\n            return {\"success\": True}\n        self.client.TransferFunds.side_effect = transfer_side_effect\n\n        # RecordAuditEvent should accept a non-empty list and return a log_entry_id string.\n        def record_audit_side_effect(events: List[str]):\n            if not isinstance(events, list) or len(events) == 0:\n                # Matches API doc: raise InvalidRequestException if missing/empty/not a list\n                raise InvalidRequestException(\"The 'events' parameter is missing, empty, or not a list.\")\n            # For test purposes, return a deterministic log id\n            return {\"log_entry_id\": \"log-0001\"}\n        self.client.RecordAuditEvent.side_effect = record_audit_side_effect\n\n    def test_duplicate_transfers_are_recorded_and_empty_audit_is_rejected(self):\n        # Step 1: Ensure authorization is present before sensitive actions.\n        auth = self.client.CheckAuthorization()\n        self.assertTrue(auth, \"Session should be authorized before performing transfers.\")\n\n        # Step 2: Perform the same transfer twice (duplicate events expected).\n        from_acc = \"123-4567-8901\"\n        to_acc = \"222-3333-4444\"\n        amount = 100.00\n\n        resp1 = self.client.TransferFunds(from_acc, to_acc, amount)\n        resp2 = self.client.TransferFunds(from_acc, to_acc, amount)\n\n        # Validate transfer responses indicate success\n        self.assertIsInstance(resp1, dict)\n        self.assertTrue(resp1.get(\"success\"), \"First transfer should succeed.\")\n        self.assertTrue(resp2.get(\"success\"), \"Second transfer should succeed.\")\n\n        # Verify TransferFunds was called twice with the expected arguments\n        expected_calls = [\n            ((from_acc, to_acc, amount),),\n            ((from_acc, to_acc, amount),)\n        ]\n        # The mock's call_args_list entries are tuples of (args, kwargs)\n        actual_calls = [call.args for call in self.client.TransferFunds.call_args_list]\n        self.assertEqual(len(actual_calls), 2, \"TransferFunds should have been called twice.\")\n        self.assertEqual(actual_calls[0], (from_acc, to_acc, amount))\n        self.assertEqual(actual_calls[1], (from_acc, to_acc, amount))\n\n        # Step 3: Prepare audit events including duplicates (two identical transfer events)\n        # Format is arbitrary for test; real systems would use a structured event string/obj.\n        event_str = f\"TransferFunds:{from_acc}->{to_acc}:{amount:.2f}\"\n        events = [event_str, event_str]  # duplicate entries must be preserved per policy\n\n        # Call RecordAuditEvent once at the end of the session with the duplicate events\n        audit_result = self.client.RecordAuditEvent(events)\n        self.assertIsInstance(audit_result, dict)\n        self.assertIn(\"log_entry_id\", audit_result)\n        self.assertEqual(audit_result[\"log_entry_id\"], \"log-0001\", \"Audit call should return the log entry id.\")\n\n        # Verify RecordAuditEvent was called exactly once with our duplicate events list\n        self.client.RecordAuditEvent.assert_called_once_with(events)\n\n        # Step 4: Negative test - calling RecordAuditEvent with an empty list should raise InvalidRequestException\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent([])\n\n        # Also test that calling RecordAuditEvent with a non-list raises the same exception\n        with self.assertRaises(InvalidRequestException):\n            self.client.RecordAuditEvent(\"not-a-list\")\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "extracted_trace": [
      "CheckAuthorization",
      "TransferFunds",
      "TransferFunds",
      "RecordAuditEvent",
      "RecordAuditEvent",
      "RecordAuditEvent"
    ]
  }
]