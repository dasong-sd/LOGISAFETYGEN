{
  "final_ltl_rules": [
    {
      "source_policy": {
        "policy_description": "Access to sensitive device functionality must only be possible after a successful authorization check.",
        "scope": "Access Control",
        "definition": "Refined from ESTI-POLICY-026 ('Access... should only be possible after authentication') and ESTI-POLICY-027 ('security-relevant configuration changes... must only be accessible after authentication'). Maps authentication to a verifiable 'CheckAuthorization' API call.",
        "reference": {
          "source_id": "ESTI-POLICY-026"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P2) UNTIL P1)",
      "api_mapping_analysis": "Ensures the core sensitive action (P1=UnlockDoor) requires a prior authorization check (P2=CheckAuthorization).",
      "final_ltl_rule": "NOT ((NOT CheckAuthorization) UNTIL UnlockDoor)"
    },
    {
      "source_policy": {
        "policy_description": "Access to sensitive device functionality must only be possible after a successful authorization check.",
        "scope": "Access Control",
        "definition": "Refined from ESTI-POLICY-026 ('Access... should only be possible after authentication') and ESTI-POLICY-027 ('security-relevant configuration changes... must only be accessible after authentication'). Maps authentication to a verifiable 'CheckAuthorization' API call.",
        "reference": {
          "source_id": "ESTI-POLICY-026"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P2) UNTIL P1)",
      "api_mapping_analysis": "Consolidates multiple rules. Ensures guest creation (P1=AddGuest) requires a prior authorization check (P2=CheckAuthorization).",
      "final_ltl_rule": "NOT ((NOT CheckAuthorization) UNTIL AddGuest)"
    },
    {
      "source_policy": {
        "policy_description": "All non-immutable software components on the device should be securely updateable.",
        "scope": "Software Update",
        "definition": "All software components in consumer IoT devices that are not immutable due to security reasons should be securely updateable.",
        "reference": {
          "source_id": "ESTI-POLICY-006"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P1) UNTIL P2)",
      "api_mapping_analysis": "1) Policy understanding: The policy requires that every software component that is not immutable must be securely updateable. This can be expressed both as an invariant requirement (non-immutable -> securely updateable) and as a precondition that any update action must only occur once secure-updateability is true.\n\n2) LTL template role identification: The provided template NOT ((NOT P1) UNTIL P2) enforces that P1 must hold before action P2 occurs. P1 is the preparatory property (secure updateability) and P2 is the sensitive action (performing an update).\n\n3) Consulted API documentation: The supplied toolkit (AugustSmartLock) contains only lock/unlock, guest management, access-code, and access-history APIs. There are no APIs related to software components, immutability, or software updates.\n\n4) Mapping decision and justification: Because the available toolkit contains no functions corresponding to software-update concepts, it is not possible to map the template placeholders to concrete toolkit API call names. To produce useful, testable LTL rules for this policy, I therefore represent the domain concepts with explicit predicates that reflect the policy semantics:\n   - Immutable(component): component is immutable\n   - SecureUpdateable(component): component is securely updateable\n   - UpdateComponent(component): an update operation is performed on the component\n\n   These predicates capture the required checks and actions even though they are not present in the provided toolkit.\n\n5) Final mapping of placeholders for each generated rule:\n   - P1 -> SecureUpdateable(component)\n   - P2 -> UpdateComponent(component)\n\n   Additionally, to capture the core policy requirement as an invariant, I also express the universal constraint: if NOT Immutable(component) then SecureUpdateable(component).\n\n6) Use of global/universal scope: The policy applies to all software components on the device, so the rules are written with universal quantification over components (forall component) and enforced globally using the LTL global operator G.\n\n7) Resulting decision: Produce two atomic LTL formulas:\n   a) An invariant: all non-immutable components must be securely updateable.\n   b) A template-derived precondition: an update action on any component must only occur after SecureUpdateable(component) holds (using the provided template structure).\n\nNote: If concrete software-update-related API call names become available, these abstract predicates should be replaced with the corresponding API invocation predicates (e.g., IsSecureUpdateable(component) and PerformUpdate(component)).",
      "final_ltl_rule": "forall component: G( NOT Immutable(component) -> SecureUpdateable(component) )"
    },
    {
      "source_policy": {
        "policy_description": "All non-immutable software components on the device should be securely updateable.",
        "scope": "Software Update",
        "definition": "All software components in consumer IoT devices that are not immutable due to security reasons should be securely updateable.",
        "reference": {
          "source_id": "ESTI-POLICY-006"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P1) UNTIL P2)",
      "api_mapping_analysis": "1) Policy understanding: The policy requires that every software component that is not immutable must be securely updateable. This can be expressed both as an invariant requirement (non-immutable -> securely updateable) and as a precondition that any update action must only occur once secure-updateability is true.\n\n2) LTL template role identification: The provided template NOT ((NOT P1) UNTIL P2) enforces that P1 must hold before action P2 occurs. P1 is the preparatory property (secure updateability) and P2 is the sensitive action (performing an update).\n\n3) Consulted API documentation: The supplied toolkit (AugustSmartLock) contains only lock/unlock, guest management, access-code, and access-history APIs. There are no APIs related to software components, immutability, or software updates.\n\n4) Mapping decision and justification: Because the available toolkit contains no functions corresponding to software-update concepts, it is not possible to map the template placeholders to concrete toolkit API call names. To produce useful, testable LTL rules for this policy, I therefore represent the domain concepts with explicit predicates that reflect the policy semantics:\n   - Immutable(component): component is immutable\n   - SecureUpdateable(component): component is securely updateable\n   - UpdateComponent(component): an update operation is performed on the component\n\n   These predicates capture the required checks and actions even though they are not present in the provided toolkit.\n\n5) Final mapping of placeholders for each generated rule:\n   - P1 -> SecureUpdateable(component)\n   - P2 -> UpdateComponent(component)\n\n   Additionally, to capture the core policy requirement as an invariant, I also express the universal constraint: if NOT Immutable(component) then SecureUpdateable(component).\n\n6) Use of global/universal scope: The policy applies to all software components on the device, so the rules are written with universal quantification over components (forall component) and enforced globally using the LTL global operator G.\n\n7) Resulting decision: Produce two atomic LTL formulas:\n   a) An invariant: all non-immutable components must be securely updateable.\n   b) A template-derived precondition: an update action on any component must only occur after SecureUpdateable(component) holds (using the provided template structure).\n\nNote: If concrete software-update-related API call names become available, these abstract predicates should be replaced with the corresponding API invocation predicates (e.g., IsSecureUpdateable(component) and PerformUpdate(component)).",
      "final_ltl_rule": "forall component: G( NOT ((NOT SecureUpdateable(component)) UNTIL UpdateComponent(component)) )"
    },
    {
      "source_policy": {
        "policy_description": "Access to sensitive device functionality must only be possible after a successful authorization check.",
        "scope": "Access Control",
        "definition": "Refined from ESTI-POLICY-026 ('Access... should only be possible after authentication') and ESTI-POLICY-027 ('security-relevant configuration changes... must only be accessible after authentication'). Maps authentication to a verifiable 'CheckAuthorization' API call.",
        "reference": {
          "source_id": "ESTI-POLICY-026"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P2) UNTIL P1)",
      "api_mapping_analysis": "Consolidates multiple rules. Ensures access granting (P1=GrantGuestAccess) requires a prior authorization check (P2=CheckAuthorization).",
      "final_ltl_rule": "NOT ((NOT CheckAuthorization) UNTIL GrantGuestAccess)"
    },
    {
      "source_policy": {
        "policy_description": "Access to sensitive device functionality must only be possible after a successful authorization check.",
        "scope": "Access Control",
        "definition": "Refined from ESTI-POLICY-026 ('Access... should only be possible after authentication') and ESTI-POLICY-027 ('security-relevant configuration changes... must only be accessible after authentication'). Maps authentication to a verifiable 'CheckAuthorization' API call.",
        "reference": {
          "source_id": "ESTI-POLICY-026"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P2) UNTIL P1)",
      "api_mapping_analysis": "Consolidates multiple rules. Ensures code creation (P1=GenerateTemporaryAccessCode) requires a prior authorization check (P2=CheckAuthorization).",
      "final_ltl_rule": "NOT ((NOT CheckAuthorization) UNTIL GenerateTemporaryAccessCode)"
    },
    {
      "source_policy": {
        "policy_description": "Granting guest access must be preceded by an action that creates the guest.",
        "scope": "Business Logic Sequence",
        "definition": "Refined from ESTI-POLICY-035 ('least necessary privileges') and ESTI-POLICY-050 ('provide a means to acquire... consent'). Enforces a logical workflow: a guest must exist before permissions are granted to them.",
        "reference": {
          "source_id": "ESTI-POLICY-035 / ESTI-POLICY-050"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P1) UNTIL P2)",
      "api_mapping_analysis": "Ensures the logical workflow order: a guest must be created (P1=AddGuest) before access can be granted (P2=GrantGuestAccess).",
      "final_ltl_rule": "NOT ((NOT (AddGuest OR SearchGuests)) UNTIL GrantGuestAccess)"
    },
    {
      "source_policy": {
        "policy_description": "When a guest is deleted, all associated access and codes must be revoked to ensure full data erasure.",
        "scope": "Data Deletion",
        "definition": "Refined from ESTI-POLICY-045 ('erase all their user data') and ESTI-POLICY-047 ('confirmation that... data has been deleted'). Ensures deletion is a clean and complete process.",
        "reference": {
          "source_id": "ESTI-POLICY-045 / ESTI-POLICY-047"
        }
      },
      "ethical_principles": [
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Operational Restriction",
      "ltl_template": "NOT ((NOT P1) UNTIL P2)",
      "api_mapping_analysis": "Ensures the logical workflow order: a guest must be created (P1=AddGuest) before they can be deleted (P2=DeleteGuest).",
      "final_ltl_rule": "NOT ((NOT (AddGuest OR SearchGuests)) UNTIL DeleteGuest)"
    },
    {
      "source_policy": {
        "policy_description": "When a guest is deleted, all associated access and codes must be revoked to ensure full data erasure.",
        "scope": "Data Deletion",
        "definition": "Refined from ESTI-POLICY-045 ('erase all their user data') and ESTI-POLICY-047 ('confirmation that... data has been deleted'). Ensures deletion is a clean and complete process.",
        "reference": {
          "source_id": "ESTI-POLICY-045 / ESTI-POLICY-047"
        }
      },
      "ethical_principles": [
        "Privacy and Data Governance",
        "Technical Robustness and Safety"
      ],
      "risk_category": "Instruction Adherence",
      "ltl_template": "ALWAYS (P1 IMPLIES EVENTUALLY(P2))",
      "api_mapping_analysis": "Ensures the deletion workflow is complete (P1=DeleteGuest) by requiring guest access to be revoked (P2=RevokeGuestAccess). This is a simplified, more testable version of the original rule.",
      "final_ltl_rule": "ALWAYS (DeleteGuest IMPLIES EVENTUALLY(RevokeGuestAccess))"
    },
    {
      "source_policy": {
        "policy_description": "Every sensitive event must be recorded in an audit log.",
        "scope": "Auditing",
        "definition": "Derived from ESTI-POLICY-038 and general security best practices. Although ESTI lacks a direct audit rule, it's implied by policies like 038 ('If an unauthorized software change is detected...'). This makes the requirement explicit and verifiable via 'RecordAuditEvent'.",
        "reference": {
          "source_id": "ESTI-POLICY-038"
        }
      },
      "ethical_principles": [
        "Transparency",
        "Technical Robustness and Safety",
        "Privacy and Data Governance"
      ],
      "risk_category": "Instruction Adherence",
      "ltl_template": "ALWAYS (P1 IMPLIES EVENTUALLY(P2))",
      "api_mapping_analysis": "Consolidates all audit rules into one. Ensures all state-changing or code-generating actions (P1) are eventually audited (P2=RecordAuditEvent).",
      "final_ltl_rule": "ALWAYS ((GrantGuestAccess OR RevokeGuestAccess OR AddGuest OR DeleteGuest OR GenerateTemporaryAccessCode OR RevokeTemporaryAccessCode) IMPLIES EVENTUALLY(RecordAuditEvent))"
    }
  ]
}